<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Elon Musk Tweet Activity Heatmap</title>

    <!-- Resource hints for better performance -->
    <link rel="dns-prefetch" href="//corsproxy.io">
    <link rel="dns-prefetch" href="//www.xtracker.io">
    <link rel="preconnect" href="https://corsproxy.io" crossorigin>
    <link rel="preconnect" href="https://www.xtracker.io" crossorigin>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: "class",
      };
    </script>
    <style>
      /* Smooth transitions for data updates */
      .fade-enter {
        opacity: 0;
        transform: translateY(10px);
      }
      .fade-enter-active {
        opacity: 1;
        transform: translateY(0);
        transition: opacity 0.3s ease, transform 0.3s ease;
      }
      .fade-exit {
        opacity: 1;
      }
      .fade-exit-active {
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      /* Cell animation */
      .cell-update {
        animation: cellPulse 0.5s ease;
      }

      @keyframes cellPulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); opacity: 0.8; }
        100% { transform: scale(1); opacity: 1; }
      }

      /* Smooth color transitions */
      .heatmap-cell {
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }

      /* Loading animation */
      @keyframes shimmer {
        0% { background-position: -468px 0; }
        100% { background-position: 468px 0; }
      }

      .shimmer {
        animation: shimmer 2s ease-in-out infinite;
        background: linear-gradient(to right, transparent 0%, rgba(255,255,255,0.2) 50%, transparent 100%);
        background-size: 1000px 100%;
      }

      /* Pull to refresh styles */
      .pull-to-refresh {
        position: fixed;
        top: -60px;
        left: 0;
        right: 0;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(to bottom, rgba(59, 130, 246, 0.1), transparent);
        transition: transform 0.3s ease;
        z-index: 100;
      }

      .pull-to-refresh.pulling {
        transform: translateY(60px);
      }

      .pull-to-refresh.refreshing {
        transform: translateY(60px);
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      .pull-to-refresh.refreshing .refresh-icon {
        animation: spin 1s linear infinite;
      }
    </style>
  </head>
  <body
    class="bg-gray-50 dark:bg-gray-900 p-5 transition-colors duration-300 font-sans"
  >
    <!-- Pull to refresh indicator -->
    <div id="pullToRefresh" class="pull-to-refresh">
      <div class="text-center">
        <div class="refresh-icon text-2xl mb-1">üîÑ</div>
        <div class="text-xs text-gray-600 dark:text-gray-400" id="pullText">Pull to refresh</div>
      </div>
    </div>
    <div
      class="max-w-6xl mx-auto bg-white dark:bg-gray-800 rounded-lg shadow-lg p-5 transition-colors duration-300"
    >
      <div
        class="flex justify-between items-center mb-4 pb-3 border-b border-gray-200 dark:border-gray-700 flex-wrap gap-3"
      >
        <h1 class="text-xl font-bold text-gray-900 dark:text-gray-100">
          üê¶ Elon Musk Tweet Activity
        </h1>
        <div class="flex items-center gap-2 flex-wrap">
          <div class="flex items-center gap-2">
            <label
              for="weekRange"
              class="text-sm text-gray-600 dark:text-gray-300 font-bold"
              >Date Range:</label
            >
            <select
              id="weekRange"
              class="px-3 py-1.5 text-sm border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-200 font-bold"
              onchange="updateDateRange()"
            >
              <option value="">Select a week range...</option>
            </select>
          </div>
          <button
            onclick="handleButtonClick(event, () => loadData(true))"
            class="px-3 py-1.5 text-sm bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 text-white rounded-md font-bold transition-all duration-200 transform active:scale-95"
          >
            üîÑ Update Now
          </button>
          <button
            onclick="handleButtonClick(event, toggleAutoRefresh)"
            id="autoRefreshBtn"
            class="px-3 py-1.5 text-sm bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 text-white rounded-md font-bold transition-all duration-200 transform active:scale-95"
          >
            ‚è∞ Auto Refresh: ON
          </button>
          <button
            onclick="handleButtonClick(event, downloadCSV)"
            class="px-3 py-1.5 text-sm bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 rounded-md font-bold transition-all duration-200 transform active:scale-95"
          >
            üì• Download Data
          </button>
          <button
            onclick="handleButtonClick(event, toggleDarkMode)"
            class="px-3 py-1.5 text-sm bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 rounded-md font-bold transition-all duration-200 transform active:scale-95"
          >
            <span id="darkModeIcon">üåô</span>
            <span id="darkModeText">Dark Mode</span>
          </button>
        </div>
      </div>

      <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-3 my-4">
        <div class="bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
          <div class="text-gray-500 dark:text-gray-300 text-xs font-bold mb-1">
            Current Week
          </div>
          <div
            id="currentValue"
            class="text-base font-bold text-gray-900 dark:text-gray-100"
          >
            -
          </div>
        </div>
        <div class="bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
          <div class="text-gray-500 dark:text-gray-300 text-xs font-bold mb-1">
            4-Week Avg
          </div>
          <div
            id="avgValue"
            class="text-base font-bold text-gray-900 dark:text-gray-100"
          >
            -
          </div>
        </div>
        <div class="bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
          <div class="text-gray-500 dark:text-gray-300 text-xs font-bold mb-1">
            Peak Hour
          </div>
          <div
            id="peakHour"
            class="text-base font-bold text-gray-900 dark:text-gray-100"
          >
            -
          </div>
        </div>
        <div class="bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
          <div class="text-gray-500 dark:text-gray-300 text-xs font-bold mb-1">
            Most Active Day
          </div>
          <div
            id="mostActiveDay"
            class="text-base font-bold text-gray-900 dark:text-gray-100"
          >
            -
          </div>
        </div>
        <div class="bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
          <div class="text-gray-500 dark:text-gray-300 text-xs font-bold mb-1">
            Last Updated
          </div>
          <div
            id="lastUpdated"
            class="text-base font-bold text-gray-900 dark:text-gray-100"
          >
            -
          </div>
        </div>
        <div
          class="bg-gray-100 dark:bg-gray-700 p-3 rounded-lg hidden"
          id="refreshCountdownIndicator"
        >
          <div class="text-gray-500 dark:text-gray-300 text-xs font-bold mb-1">
            Next Refresh
          </div>
          <div
            id="refreshCountdown"
            class="text-base font-bold text-gray-900 dark:text-gray-100"
          >
            -
          </div>
        </div>
      </div>

      <div
        class="bg-blue-50 dark:bg-blue-900/20 border border-blue-300 dark:border-blue-700 rounded-lg p-3 mt-3"
      >
        <div class="grid grid-cols-2 md:grid-cols-4 gap-3">
          <div class="bg-white dark:bg-gray-800 p-2 rounded-lg">
            <div
              class="flex items-center text-gray-500 dark:text-gray-300 text-xs font-bold mb-1"
            >
              <span class="mr-1 text-xs">‚è±Ô∏è</span> Current Pace
            </div>
            <div
              id="currentPace"
              class="text-sm font-bold text-gray-900 dark:text-gray-100"
            >
              -
            </div>
          </div>
          <div class="bg-white dark:bg-gray-800 p-2 rounded-lg">
            <div
              class="flex items-center text-gray-500 dark:text-gray-300 text-xs font-bold mb-1"
            >
              <span class="mr-1 text-xs">üîÆ</span> Next 24h
            </div>
            <div
              id="next24hPrediction"
              class="text-sm font-bold text-gray-900 dark:text-gray-100"
            >
              -
            </div>
          </div>
          <div class="bg-white dark:bg-gray-800 p-2 rounded-lg">
            <div
              class="flex items-center text-gray-500 dark:text-gray-300 text-xs font-bold mb-1"
            >
              <span class="mr-1 text-xs">üéØ</span> End of Range
            </div>
            <div
              id="weekEndPrediction"
              class="text-sm font-bold text-gray-900 dark:text-gray-100"
            >
              -
            </div>
          </div>
          <div class="bg-white dark:bg-gray-800 p-2 rounded-lg">
            <div
              class="flex items-center text-gray-500 dark:text-gray-300 text-xs font-bold mb-1"
            >
              <span class="mr-1 text-xs">üìä</span> Trend
            </div>
            <div
              id="trendIndicator"
              class="text-sm font-bold text-gray-900 dark:text-gray-100"
            >
              -
            </div>
          </div>
        </div>
      </div>

      <div class="grid md:grid-cols-2 gap-6 mt-6">
        <div
          class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 overflow-hidden"
        >
          <h3
            class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4"
          >
            Current Week
          </h3>
          <div id="heatmapContainer" class="overflow-x-auto">
            <!-- Skeleton loader will be inserted here -->
          </div>
        </div>
        <div
          class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 overflow-hidden"
        >
          <h3
            class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4"
          >
            4-Week Average
          </h3>
          <div id="averageHeatmapContainer" class="overflow-x-auto">
            <!-- Skeleton loader will be inserted here -->
          </div>
        </div>
      </div>

      <div
        class="flex items-center justify-center gap-2 mt-6 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg"
      >
        <span class="text-sm font-medium text-gray-600 dark:text-gray-400"
          >Less</span
        >
        <div class="flex gap-1">
          <div
            class="w-6 h-6 rounded bg-green-50 dark:bg-gray-900 border border-gray-300 dark:border-gray-600"
          ></div>
          <div
            class="w-6 h-6 rounded bg-green-200 dark:bg-green-950 border border-gray-300 dark:border-gray-600"
          ></div>
          <div
            class="w-6 h-6 rounded bg-green-300 dark:bg-green-900 border border-gray-300 dark:border-gray-600"
          ></div>
          <div
            class="w-6 h-6 rounded bg-green-500 dark:bg-green-700 border border-gray-300 dark:border-gray-600"
          ></div>
          <div
            class="w-6 h-6 rounded bg-green-700 dark:bg-green-500 border border-gray-300 dark:border-gray-600"
          ></div>
        </div>
        <span class="text-sm font-medium text-gray-600 dark:text-gray-400"
          >More</span
        >
      </div>
    </div>

    <script>
      // Configuration Constants
      const DEBUG_MODE = false; // Set to true to enable console logging
      const PREDICTION_WEIGHT_CURRENT = 0.7; // Weight for current week in predictions
      const PREDICTION_WEIGHT_AVERAGE = 0.3; // Weight for 4-week average
      const WEEKS_FOR_TREND = 4; // Number of weeks to analyze for trend
      const HOURS_IN_DAY = 24;
      const DAYS_IN_WEEK = 8; // Friday noon to Friday noon
      const AUTO_REFRESH_INTERVAL = 60000; // 1 minute in milliseconds
      const TREND_UP_THRESHOLD = 1.15; // 15% increase for upward trend
      const TREND_DOWN_THRESHOLD = 0.85; // 15% decrease for downward trend

      // Debug logging wrapper
      const debugLog = (...args) => {
        if (DEBUG_MODE) {
          console.log(...args);
        }
      };

      // Button click handler with visual and haptic feedback
      function handleButtonClick(event, callback) {
        const button = event.currentTarget;

        // Trigger haptic feedback for button press
        if (isMobileDevice()) {
          triggerHaptic('medium');
        }

        // Add ripple effect
        const ripple = document.createElement('span');
        const rect = button.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        const x = event.clientX - rect.left - size / 2;
        const y = event.clientY - rect.top - size / 2;

        ripple.style.width = ripple.style.height = size + 'px';
        ripple.style.left = x + 'px';
        ripple.style.top = y + 'px';
        ripple.className = 'absolute rounded-full bg-white opacity-30 animate-ping pointer-events-none';

        button.style.position = 'relative';
        button.style.overflow = 'hidden';
        button.appendChild(ripple);

        setTimeout(() => ripple.remove(), 600);

        // Execute callback
        if (callback) callback();
      }

      // Global Variables
      let tooltip = null;
      let currentData = null;
      let rawTweets = null; // Store raw tweet data for reprocessing
      let autoRefreshInterval = null; // Auto refresh timer
      let countdownInterval = null; // Countdown timer
      let refreshCountdown = 0; // Remaining seconds
      let isAutoRefreshEnabled = true; // Auto refresh enabled by default

      // Create tooltip element
      function createTooltip() {
        tooltip = document.createElement("div");
        tooltip.className =
          "absolute bg-gray-900 dark:bg-gray-800 text-white px-3 py-2 rounded-md text-xs pointer-events-none z-50 whitespace-nowrap shadow-xl opacity-0 transition-opacity duration-200";
        document.body.appendChild(tooltip);
      }

      // Show tooltip
      function showTooltip(event, content) {
        if (!tooltip) createTooltip();
        tooltip.textContent = content;

        // Get the target cell's position
        const rect = event.target.getBoundingClientRect();
        const scrollTop =
          window.pageYOffset || document.documentElement.scrollTop;
        const scrollLeft =
          window.pageXOffset || document.documentElement.scrollLeft;

        // Calculate initial position (above and centered)
        let left = rect.left + scrollLeft + rect.width / 2;
        let top = rect.top + scrollTop - 10;

        // Temporarily show tooltip to get its dimensions
        tooltip.style.visibility = 'hidden';
        tooltip.style.opacity = '0';
        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.style.transform = 'translateX(-50%) translateY(-100%)';

        // Get tooltip dimensions
        const tooltipRect = tooltip.getBoundingClientRect();
        const tooltipWidth = tooltipRect.width;
        const tooltipHeight = tooltipRect.height;

        // Check if tooltip goes off viewport edges
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Adjust horizontal position if needed
        if (rect.left + rect.width / 2 - tooltipWidth / 2 < 0) {
          // Too far left
          left = scrollLeft + tooltipWidth / 2 + 10;
        } else if (rect.left + rect.width / 2 + tooltipWidth / 2 > viewportWidth) {
          // Too far right
          left = scrollLeft + viewportWidth - tooltipWidth / 2 - 10;
        }

        // Adjust vertical position if needed (show below if no room above)
        if (rect.top - tooltipHeight - 10 < 0) {
          // Show below instead
          top = rect.bottom + scrollTop + 10;
          tooltip.style.transform = 'translateX(-50%) translateY(0)';
        } else {
          tooltip.style.transform = 'translateX(-50%) translateY(-100%)';
        }

        // Apply final position
        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.style.visibility = 'visible';

        tooltip.classList.remove("opacity-0");
        tooltip.classList.add("opacity-100");
      }

      // Hide tooltip
      function hideTooltip() {
        if (tooltip) {
          tooltip.classList.remove("opacity-100");
          tooltip.classList.add("opacity-0");
        }
      }

      // Haptic feedback support
      function triggerHaptic(pattern = 'light') {
        if ('vibrate' in navigator) {
          switch(pattern) {
            case 'light':
              navigator.vibrate(10);
              break;
            case 'medium':
              navigator.vibrate(25);
              break;
            case 'heavy':
              navigator.vibrate(50);
              break;
            case 'double':
              navigator.vibrate([10, 20, 10]);
              break;
            case 'success':
              navigator.vibrate([10, 50, 10, 50, 10]);
              break;
            default:
              navigator.vibrate(10);
          }
        }
      }

      // Handle touch events for mobile
      let touchTimeout = null;
      function handleCellTouch(event, content) {
        event.preventDefault(); // Prevent default touch behavior
        event.stopPropagation();

        // Trigger haptic feedback
        triggerHaptic('light');

        // Clear any existing timeout
        if (touchTimeout) {
          clearTimeout(touchTimeout);
        }

        // Show tooltip
        showTooltip(event, content);

        // Auto-hide after 2 seconds
        touchTimeout = setTimeout(() => {
          hideTooltip();
        }, 2000);
      }

      // ET timezone formatter with weekday
      const etFormatter = new Intl.DateTimeFormat("en-US", {
        timeZone: "America/New_York",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        weekday: "short",
        hour12: false,
      });

      // Get ET date components efficiently
      function getETComponents(date) {
        // Cache key based on date timestamp
        const cacheKey = date.getTime();
        if (etComponentsCache.has(cacheKey)) {
          return etComponentsCache.get(cacheKey);
        }

        // Implement LRU cache eviction for ET components
        if (etComponentsCache.size >= MAX_CACHE_SIZE) {
          const firstKey = etComponentsCache.keys().next().value;
          etComponentsCache.delete(firstKey);
        }

        const parts = etFormatter.formatToParts(date);
        const result = {};
        parts.forEach((part) => {
          if (part.type !== "literal") {
            result[part.type] = part.value;
          }
        });

        // Convert weekday name to number
        const weekdayMap = {
          Sun: 0,
          Mon: 1,
          Tue: 2,
          Wed: 3,
          Thu: 4,
          Fri: 5,
          Sat: 6,
        };

        const components = {
          year: parseInt(result.year),
          month: parseInt(result.month) - 1, // JS months are 0-indexed
          day: parseInt(result.day),
          hour: parseInt(result.hour),
          minute: parseInt(result.minute),
          second: parseInt(result.second),
          dayOfWeek: weekdayMap[result.weekday] || 0,
        };

        // Cache the result
        etComponentsCache.set(cacheKey, components);
        return components;
      }

      // Create a date at ET noon from YYYY-MM-DD components
      function createETNoonDate(year, month, day) {
        // Check if date is in EDT or EST
        // EDT: Second Sunday in March to first Sunday in November (roughly)
        // Simplified check: March 14 - November 7 is usually EDT
        const isEDT =
          (month > 3 && month < 11) ||
          (month === 3 && day >= 14) ||
          (month === 11 && day <= 7);

        // ET noon in UTC:
        // EDT (UTC-4): 12:00 PM ET = 16:00 UTC
        // EST (UTC-5): 12:00 PM ET = 17:00 UTC
        const utcHour = isEDT ? 16 : 17;

        return new Date(Date.UTC(year, month - 1, day, utcHour, 0, 0));
      }

      // Parse YYYY-MM-DD string and create ET noon date
      function parseETNoonDate(dateString) {
        const [year, month, day] = dateString.split("-").map(Number);
        return createETNoonDate(year, month, day);
      }

      // Date cache for performance
      const dateCache = new Map();
      const MAX_CACHE_SIZE = 1000; // Limit cache size to prevent memory issues
      const etComponentsCache = new Map(); // Cache for ET components

      // Parse Twitter date format and convert to ET
      function parseTwitterDate(dateStr) {
        // Check cache first
        if (dateCache.has(dateStr)) {
          return dateCache.get(dateStr);
        }

        // Implement LRU cache eviction
        if (dateCache.size >= MAX_CACHE_SIZE) {
          // Remove oldest entry
          const firstKey = dateCache.keys().next().value;
          dateCache.delete(firstKey);
        }
        try {
          // Handle formats like "MMM DD, HH:MM:SS AM/PM EDT/EST"
          let cleanDate = dateStr.trim();
          let isEDT = cleanDate.includes(" EDT");
          let isEST = cleanDate.includes(" EST");

          // Remove timezone suffix
          cleanDate = cleanDate.replace(" EDT", "").replace(" EST", "");

          // Add current year if missing
          if (!cleanDate.match(/\b20\d{2}\b/)) {
            const parts = cleanDate.split(", ");
            if (parts.length >= 2) {
              // Use ET current year for dates without year
              const nowET = getETComponents(new Date());
              const currentYear = nowET.year;
              cleanDate =
                parts[0] +
                ", " +
                currentYear +
                ", " +
                parts.slice(1).join(", ");
            }
          }

          // Parse the date components to create a proper ET date
          // Extract month, day, year, time parts
          const dateMatch = cleanDate.match(
            /^(\w+)\s+(\d+),\s+(\d{4}),\s+(\d{1,2}):(\d{2}):(\d{2})\s+(AM|PM)$/
          );

          if (!dateMatch) {
            debugLog("Failed to match date pattern:", cleanDate);
            return null;
          }

          const [
            _,
            monthStr,
            dayStr,
            yearStr,
            hourStr,
            minuteStr,
            secondStr,
            ampm,
          ] = dateMatch;

          // Convert month name to number
          const monthNames = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec",
          ];
          const month = monthNames.indexOf(monthStr.substring(0, 3)) + 1; // 1-based month
          if (month === 0) {
            debugLog("Invalid month:", monthStr);
            return null;
          }

          const day = parseInt(dayStr);
          const year = parseInt(yearStr);
          let hour = parseInt(hourStr);
          const minute = parseInt(minuteStr);
          const second = parseInt(secondStr);

          // Convert 12-hour to 24-hour format
          if (ampm === "PM" && hour !== 12) {
            hour += 12;
          } else if (ampm === "AM" && hour === 12) {
            hour = 0;
          }

          // Create a UTC date from ET components
          // EDT is UTC-4 (so ET hour + 4 = UTC hour)
          // EST is UTC-5 (so ET hour + 5 = UTC hour)
          const utcOffsetHours = isEDT ? 4 : 5;

          // Create the date in UTC by adjusting the ET hour
          const utcDate = new Date(
            Date.UTC(
              year,
              month - 1, // JavaScript months are 0-based
              day,
              hour + utcOffsetHours, // Convert ET hour to UTC
              minute,
              second
            )
          );

          // Debug log for parsed dates
          if (Math.random() < 0.01) {
            // Log 1% of dates to avoid spam
            debugLog("parseTwitterDate:", {
              input: dateStr,
              parsed: cleanDate,
              isEDT,
              components: { year, month, day, hour, minute, second, ampm },
              utcDate: utcDate.toISOString(),
              etCheck: getETComponents(utcDate),
            });
          }

          // Cache the result before returning
          dateCache.set(dateStr, utcDate);
          return utcDate;
        } catch (error) {
          debugLog("Date parsing error:", error, "for:", dateStr);
          // Cache null result to avoid re-parsing invalid dates
          dateCache.set(dateStr, null);
          return null;
        }
      }

      // Parse CSV data with optimization for large files
      function parseCSV(csvText, weeksToLoad = 5) {
        const data = [];

        debugLog(`Processing CSV for last ${weeksToLoad} weeks...`);

        // Simple approach: Find all lines ending with EDT or EST
        // This avoids multiline parsing issues
        const lines = csvText.split("\n");
        const tweetLines = [];

        // Find all lines that end with EDT" or EST"
        lines.forEach((line, index) => {
          if (line.endsWith('EDT"') || line.endsWith('EST"')) {
            tweetLines.push(line);
          }
        });

        debugLog(`Found ${tweetLines.length} tweets by EDT/EST pattern`);

        // Process from the end (newest tweets first) to get accurate dates
        const now = new Date();
        const cutoffDate = new Date(now);
        cutoffDate.setTime(
          cutoffDate.getTime() - weeksToLoad * 7 * 24 * 60 * 60 * 1000
        );

        // Use ET components to get the current year
        const nowET = getETComponents(now);
        let currentYear = nowET.year;
        let lastMonth = 13; // Start with invalid month to detect year change

        // Process tweets in reverse order (newest first)
        for (let i = tweetLines.length - 1; i >= 0; i--) {
          const line = tweetLines[i];
          // Extract the date/time part (everything after the last comma before EDT/EST)
          const edtIndex = line.lastIndexOf('EDT"');
          const estIndex = line.lastIndexOf('EST"');
          const timeEndIndex = edtIndex > 0 ? edtIndex : estIndex;

          if (timeEndIndex > 0) {
            // Find the quote before the date
            const beforeTime = line.substring(0, timeEndIndex);
            const lastQuoteBeforeTime = beforeTime.lastIndexOf('"');

            if (lastQuoteBeforeTime > 0) {
              const dateTimeStr =
                beforeTime.substring(lastQuoteBeforeTime + 1) +
                (edtIndex > 0 ? "EDT" : "EST");

              // Parse date with smart year detection
              const monthMatch = dateTimeStr.match(/^(\w+) (\d+)/);
              if (monthMatch) {
                const monthNames = [
                  "Jan",
                  "Feb",
                  "Mar",
                  "Apr",
                  "May",
                  "Jun",
                  "Jul",
                  "Aug",
                  "Sep",
                  "Oct",
                  "Nov",
                  "Dec",
                ];
                const monthIndex = monthNames.indexOf(monthMatch[1]);

                // Detect year change when going backwards
                if (monthIndex > lastMonth && lastMonth !== 13) {
                  currentYear--;
                }
                lastMonth = monthIndex;
              }

              // Create date string with estimated year
              const dateWithYear = dateTimeStr.replace(
                /^(\w+ \d+)/,
                `$1, ${currentYear}`
              );

              // Parse and check if within range
              const tweetDate = parseTwitterDate(dateWithYear);
              if (tweetDate && tweetDate >= cutoffDate) {
                // Remove the upper bound check to include all recent tweets
                // Add to beginning since we're processing in reverse
                data.unshift({
                  id: null,
                  text: null,
                  created_at: dateWithYear,
                });
              } else if (tweetDate && tweetDate < cutoffDate) {
                // Stop processing if we've gone too far back
                break;
              }
            }
          }
        }

        debugLog(`Parsed ${data.length} tweets`);

        // Debug: Show sample of parsed data
        debugLog("Sample parsed tweets:", data.slice(0, 5));
        debugLog("Last few parsed tweets:", data.slice(-5));

        // Debug: Check for today's tweets
        const today = new Date();
        const todayET = getETComponents(today);
        const todayStr = `${todayET.year}-${String(todayET.month + 1).padStart(
          2,
          "0"
        )}-${String(todayET.day).padStart(2, "0")}`;
        const todayTweets = data.filter((tweet) => {
          const tweetDate = parseTwitterDate(tweet.created_at);
          if (tweetDate) {
            const tweetET = getETComponents(tweetDate);
            const tweetStr = `${tweetET.year}-${String(
              tweetET.month + 1
            ).padStart(2, "0")}-${String(tweetET.day).padStart(2, "0")}`;
            return tweetStr === todayStr;
          }
          return false;
        });
        debugLog(
          `Today's tweets (${todayStr}):`,
          todayTweets.length,
          todayTweets.slice(0, 3)
        );

        // Debug: Count tweets for a sample date
        if (data.length > 0) {
          const sampleDate = data[0].created_at
            ? data[0].created_at.split(",")[0]
            : "";
          const sampleCount = data.filter(
            (tweet) => tweet.created_at && tweet.created_at.includes(sampleDate)
          ).length;
          debugLog(`Sample date (${sampleDate}) tweets:`, sampleCount);

          // Debug: Show date range
          const firstTweet = data[0];
          const lastTweet = data[data.length - 1];
          if (firstTweet && lastTweet) {
            const firstDate = parseTwitterDate(firstTweet.created_at);
            const lastDate = parseTwitterDate(lastTweet.created_at);
            if (firstDate && lastDate) {
              const firstET = getETComponents(firstDate);
              const lastET = getETComponents(lastDate);
              debugLog("Tweet date range:", {
                first: `${firstET.year}-${firstET.month + 1}-${firstET.day} ${
                  firstET.hour
                }:${firstET.minute}`,
                last: `${lastET.year}-${lastET.month + 1}-${lastET.day} ${
                  lastET.hour
                }:${lastET.minute}`,
                totalTweets: data.length,
              });
            }
          }
        }

        return data;
      }

      // Get Tailwind classes for heatmap cells
      function getHeatmapTailwindClasses(
        value,
        maxValue,
        isDisabled,
        isFuture
      ) {
        if (isDisabled) {
          return "bg-gray-100 dark:bg-gray-800 text-gray-400 dark:text-gray-600 border-dashed cursor-not-allowed";
        }
        if (isFuture) {
          return "bg-gray-50 dark:bg-gray-900 text-gray-400 dark:text-gray-600 border-dashed opacity-60";
        }

        // Light mode: green gradient, Dark mode: green gradient
        if (value === 0) return "bg-green-50 dark:bg-gray-900";
        if (value > 0 && value <= 2) return "bg-green-200 dark:bg-green-950";
        if (value <= 4) return "bg-green-300 dark:bg-green-900";
        if (value <= 7) return "bg-green-500 dark:bg-green-700";
        if (value <= 9) return "bg-green-600 dark:bg-green-600";
        return "bg-green-700 dark:bg-green-500"; // 10+
      }

      // Format hour for display
      function formatHour(hour) {
        if (hour === 0) return "12 AM";
        if (hour === 12) return "12 PM";
        if (hour < 12) return `${hour} AM`;
        return `${hour - 12} PM`;
      }

      // Helper function to create colgroup for consistent column widths
      function createColgroup(columnCount) {
        let html = '<colgroup>';
        // First column for hour labels (fixed width)
        html += '<col style="width: 60px;">';
        // Data columns (equal width)
        const dataColWidth = `${100 / (columnCount + 1)}%`;
        for (let i = 0; i < columnCount; i++) {
          html += `<col style="width: ${dataColWidth};">`;
        }
        html += '</colgroup>';
        return html;
      }

      // Helper function to create heatmap table header
      function createHeatmapHeader(days) {
        let html = '<tr class="border-b border-gray-200 dark:border-gray-700">';
        html +=
          '<th class="text-right pr-2 text-xs text-gray-600 dark:text-gray-400 font-medium"></th>';
        days.forEach((day) => {
          html += `<th class="px-1 py-1 text-xs text-gray-700 dark:text-gray-300 font-semibold text-center border-l border-gray-200 dark:border-gray-700">${day}</th>`;
        });
        html += "</tr>";
        return html;
      }

      // Helper function to create totals row
      function createTotalsRow(totals, label = "TOTALS") {
        let html = '<tr class="bg-gray-100 dark:bg-gray-800 font-bold">';
        html += `<td class="p-2 text-center text-xs text-gray-700 dark:text-gray-300 font-bold">${label}</td>`;
        totals.forEach((total) => {
          html += `<td class="p-2 text-center text-xs text-gray-700 dark:text-gray-300 font-bold border border-gray-200 dark:border-gray-700">${total}</td>`;
        });
        html += "</tr>";
        return html;
      }

      // Helper function to determine if cell is disabled
      function isCellDisabled(dayIndex, hourIndex, days, dateRange) {
        if (!dateRange || !dateRange.start || !dateRange.end) return false;
        // First day before noon: disabled
        if (dayIndex === 0 && hourIndex < 12) return true;
        // Last day from noon onwards: disabled
        if (dayIndex === days.length - 1 && hourIndex >= 12) return true;
        return false;
      }

      // Helper function to check if cell is current time
      function isCurrentHour(day, hourIndex) {
        const now = new Date();
        const nowET = getETComponents(now);
        const dayNames = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"];
        const currentDayName = dayNames[nowET.dayOfWeek];
        return day === currentDayName && hourIndex === nowET.hour;
      }

      // Helper function to check if cell is future time
      function isFutureTime(dateRange, dayIndex, hourIndex) {
        if (!dateRange || !dateRange.start) return false;

        const now = new Date();
        const nowET = getETComponents(now);

        let startDateStr;
        if (typeof dateRange.start === "string") {
          startDateStr = dateRange.start;
        } else {
          const startDate = new Date(dateRange.start);
          const startET = getETComponents(startDate);
          const year = startET.year;
          const month = String(startET.month + 1).padStart(2, "0");
          const day = String(startET.day).padStart(2, "0");
          startDateStr = `${year}-${month}-${day}`;
        }

        const startDateET = parseETNoonDate(startDateStr);
        const cellDateNoonET = new Date(
          startDateET.getTime() + dayIndex * 24 * 60 * 60 * 1000
        );
        const cellET = getETComponents(cellDateNoonET);

        return (
          cellET.year > nowET.year ||
          (cellET.year === nowET.year && cellET.month > nowET.month) ||
          (cellET.year === nowET.year &&
            cellET.month === nowET.month &&
            cellET.day > nowET.day) ||
          (cellET.year === nowET.year &&
            cellET.month === nowET.month &&
            cellET.day === nowET.day &&
            hourIndex > nowET.hour)
        );
      }

      // Helper function to generate day labels
      function generateDayLabels(startDate, dayCount) {
        const days = [];
        const dayNames = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"];

        for (let i = 0; i < dayCount; i++) {
          const currentDate = new Date(
            startDate.getTime() + i * 24 * 60 * 60 * 1000
          );
          const etComponents = getETComponents(currentDate);
          const dayOfWeek = etComponents.dayOfWeek;
          days.push(dayNames[dayOfWeek]);
        }

        return days;
      }

      // Process data into heatmap
      function processData(tweets, startDate, endDate, rangeType = "friday") {
        const hours = Array.from({ length: 24 }, (_, i) => formatHour(i));

        let validTweets = 0;

        // Parse dates as ET noon (12:00 PM ET)
        let actualStart = null;
        let actualEnd = null;

        if (startDate && endDate) {
          // Use common function to create ET noon dates
          actualStart = parseETNoonDate(startDate);
          actualEnd = parseETNoonDate(endDate);
        }

        // Determine the actual date range and days to show
        let days, grid;

        if (actualStart && actualEnd) {
          // Always 8 days for noon-to-noon ranges
          const dayCount = 8;

          // Generate day labels based on actual dates
          days = generateDayLabels(actualStart, dayCount);

          debugLog("=== DATE RANGE DEBUG ===");
          debugLog("Input startDate:", startDate);
          debugLog("Input endDate:", endDate);
          debugLog("Parsed start:", actualStart);
          debugLog("Parsed end:", actualEnd);
          debugLog("Day count:", dayCount);
          debugLog("Generated days for range:", days);
          const startET = getETComponents(actualStart);
          const dayNames = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"];
          debugLog(
            "Start date day of week:",
            startET.dayOfWeek,
            "(" + dayNames[startET.dayOfWeek] + ")"
          );

          // Initialize grid based on actual day count
          grid = Array(24)
            .fill()
            .map(() => Array(days.length).fill(0));
        } else {
          // Default to full week starting Monday
          days = ["MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"];
          grid = Array(24)
            .fill()
            .map(() => Array(7).fill(0));
        }

        let totalProcessed = 0;
        let validDates = 0;
        let filteredOut = 0;
        let noonFiltered = 0;

        tweets.forEach((tweet) => {
          totalProcessed++;
          const date = parseTwitterDate(tweet.created_at);
          if (date) {
            validDates++;

            // Filter out dates that are more than 1 day in the future
            // This allows for timezone differences while still filtering obvious errors
            const now = new Date();
            const tomorrow = new Date(now);
            tomorrow.setTime(tomorrow.getTime() + 24 * 60 * 60 * 1000);
            if (date > tomorrow) {
              filteredOut++;
              return;
            }

            // Apply date range and noon filtering
            if (actualStart && actualEnd) {
              // Create date strings for comparison (YYYY-MM-DD format)
              const tweetET = getETComponents(date);
              const tweetYear = tweetET.year;
              const tweetMonth = String(tweetET.month + 1).padStart(2, "0");
              const tweetDay = String(tweetET.day).padStart(2, "0");
              const tweetDateStr = `${tweetYear}-${tweetMonth}-${tweetDay}`;
              const tweetHour = tweetET.hour;

              // For start date: include only from noon onwards
              if (tweetDateStr === startDate) {
                if (tweetHour < 12) {
                  noonFiltered++;
                  return;
                }
              }
              // For dates before start date: exclude all
              else if (tweetDateStr < startDate) {
                filteredOut++;
                return;
              }

              // For end date (Friday): include only before noon
              if (tweetDateStr === endDate) {
                if (tweetHour >= 12) {
                  noonFiltered++;
                  return;
                }
              }
              // For dates after end date: exclude all
              else if (tweetDateStr > endDate) {
                filteredOut++;
                return;
              }
            }

            const dateET = getETComponents(date);
            const hour = dateET.hour;

            if (actualStart && actualEnd) {
              // Calculate which day column this date falls into
              // Use ET components for accurate day calculation
              const tweetET = getETComponents(date);
              const startET = getETComponents(actualStart);

              // Create YYYY-MM-DD strings for both dates
              const tweetDateStr = `${tweetET.year}-${String(
                tweetET.month + 1
              ).padStart(2, "0")}-${String(tweetET.day).padStart(2, "0")}`;
              const startDateStr = `${startET.year}-${String(
                startET.month + 1
              ).padStart(2, "0")}-${String(startET.day).padStart(2, "0")}`;

              // Create dates at ET midnight (start of day) for accurate day difference
              // Use common function that handles EDT/EST properly
              const tweetDayStart = parseETNoonDate(tweetDateStr);
              const startDayStart = parseETNoonDate(startDateStr);

              // Adjust to midnight by subtracting 12 hours from noon
              tweetDayStart.setTime(
                tweetDayStart.getTime() - 12 * 60 * 60 * 1000
              );
              startDayStart.setTime(
                startDayStart.getTime() - 12 * 60 * 60 * 1000
              );

              const daysDiff = Math.floor(
                (tweetDayStart - startDayStart) / (1000 * 60 * 60 * 24)
              );

              // Allow daysDiff from 0 to 7 (8 days total)
              if (daysDiff >= 0 && daysDiff < days.length) {
                grid[hour][daysDiff]++;
                validTweets++;
              }
            } else {
              // Default behavior - map to day of week
              const dateET = getETComponents(date);
              const dayOfWeek = dateET.dayOfWeek; // 0 = Sunday, 1 = Monday, etc.
              const adjustedDay = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Convert to Monday = 0

              if (adjustedDay >= 0 && adjustedDay < days.length) {
                grid[hour][adjustedDay]++;
                validTweets++;
              }
            }
          }
        });

        // Calculate totals excluding disabled cells (noon rules)
        const totals = days.map((_, dayIndex) => {
          let total = 0;
          for (let hourIndex = 0; hourIndex < 24; hourIndex++) {
            // Skip disabled cells based on noon rules
            if (dayIndex === 0 && hourIndex < 12) continue; // First Friday before noon
            if (dayIndex === days.length - 1 && hourIndex >= 12) continue; // Last Friday from noon
            total += grid[hourIndex][dayIndex];
          }
          return total;
        });

        const maxValue = Math.max(...grid.flat());
        const peakHourIndex = grid.findIndex((row) => row.includes(maxValue));
        const peakHour = formatHour(peakHourIndex);
        const mostActiveDayIndex = totals.indexOf(Math.max(...totals));
        const mostActiveDay = days[mostActiveDayIndex];

        // Debug logging
        debugLog("=== PROCESSING SUMMARY ===");
        debugLog("Total tweets processed:", totalProcessed);
        debugLog("Valid dates parsed:", validDates);
        debugLog("Filtered out by date range:", filteredOut);
        debugLog("Filtered out by noon rule:", noonFiltered);
        debugLog("Final valid tweets:", validTweets);
        if (actualStart && actualEnd) {
          const startET = getETComponents(actualStart);
          const endET = getETComponents(actualEnd);
          debugLog("Date range:", {
            start: `${startET.year}-${startET.month + 1}-${startET.day}`,
            end: `${endET.year}-${endET.month + 1}-${endET.day}`,
            startDate: startDate,
            endDate: endDate,
          });
        }

        return {
          grid,
          hours,
          days,
          totals,
          current: validTweets,
          maxValue,
          peakHour,
          mostActiveDay,
          dateRange: { start: actualStart, end: actualEnd },
        };
      }

      // Memoized prediction calculation
      const calculatePredictionsMemoized = memoize(
        function(currentData, avgData) {
          return calculatePredictionsInternal(currentData, avgData);
        },
        (curr, avg) => `pred_${curr?.current}_${avg?.current}_${curr?.dateRange?.start}_${curr?.dateRange?.end}`
      );

      // Prediction functions
      function calculatePredictions(currentData, avgData) {
        return calculatePredictionsMemoized(currentData, avgData);
      }

      function calculatePredictionsInternal(currentData, avgData) {
        // Validate input data
        if (!currentData || !avgData)
          return { next24h: 0, endOfRange: 0, trend: "stable", pace: "-" };

        // Ensure current values are non-negative
        if (currentData.current < 0) currentData.current = 0;
        if (avgData.current < 0) avgData.current = 0;

        // Calculate current pace and projection
        const now = new Date();
        let elapsedHours = 0;
        let pace = "-";
        let totalHours = 0; // Define at outer scope

        if (
          currentData.dateRange &&
          currentData.dateRange.start &&
          currentData.dateRange.end
        ) {
          // Handle both string and Date object formats
          let startYYYYMMDD, endYYYYMMDD;

          if (typeof currentData.dateRange.start === "string") {
            startYYYYMMDD = currentData.dateRange.start;
          } else {
            const startET = getETComponents(
              new Date(currentData.dateRange.start)
            );
            startYYYYMMDD = `${startET.year}-${String(
              startET.month + 1
            ).padStart(2, "0")}-${String(startET.day).padStart(2, "0")}`;
          }

          if (typeof currentData.dateRange.end === "string") {
            endYYYYMMDD = currentData.dateRange.end;
          } else {
            const endET = getETComponents(new Date(currentData.dateRange.end));
            endYYYYMMDD = `${endET.year}-${String(endET.month + 1).padStart(
              2,
              "0"
            )}-${String(endET.day).padStart(2, "0")}`;
          }

          // Parse dates and set to ET noon using common function
          const startDate = parseETNoonDate(startYYYYMMDD);
          const endDate = parseETNoonDate(endYYYYMMDD);

          // Timezone verification
          debugLog("Timezone check:", {
            startYYYYMMDD,
            endYYYYMMDD,
            startDate_KST: startDate.toLocaleString("ko-KR", {
              timeZone: "Asia/Seoul",
            }),
            endDate_KST: endDate.toLocaleString("ko-KR", {
              timeZone: "Asia/Seoul",
            }),
            startDate_ET: startDate.toLocaleString("en-US", {
              timeZone: "America/New_York",
            }),
            endDate_ET: endDate.toLocaleString("en-US", {
              timeZone: "America/New_York",
            }),
          });

          // Calculate elapsed hours
          elapsedHours = Math.max(0, (now - startDate) / (1000 * 60 * 60));

          // Calculate total hours in the week (Friday noon to Friday noon = 7*24 = 168 hours)
          totalHours = (endDate - startDate) / (1000 * 60 * 60);

          if (elapsedHours > 0 && totalHours > 0) {
            const tweetsPerHour = currentData.current / elapsedHours;
            const remainingHours = Math.max(0, totalHours - elapsedHours);
            const projectedAdditional = Math.max(
              0,
              tweetsPerHour * remainingHours
            );
            const projectedTotal = Math.max(
              currentData.current,
              Math.round(currentData.current + projectedAdditional)
            );

            debugLog("Pace calculation:", {
              current: currentData.current,
              elapsedHours: elapsedHours.toFixed(2),
              remainingHours: remainingHours.toFixed(2),
              tweetsPerHour: tweetsPerHour.toFixed(4),
              projectedAdditional: projectedAdditional.toFixed(2),
              beforeRound: (currentData.current + projectedAdditional).toFixed(
                2
              ),
              projectedTotal: projectedTotal,
              startDate: startDate.toString(),
              endDate: endDate.toString(),
              now: now.toString(),
              totalHours: totalHours.toFixed(2),
            });

            pace = projectedTotal.toLocaleString() + " tweets";
          }
        }

        // Calculate trend factor (current week vs average for same elapsed time)
        // For trend, we need to compare only the same elapsed period
        let comparableAvgTotal = 0;
        if (elapsedHours > 0 && avgData) {
          // Calculate how many days and hours have elapsed
          const elapsedDays = Math.floor(elapsedHours / 24);
          const elapsedHoursInDay = Math.floor(elapsedHours % 24);

          // Sum up avgData.grid for the same elapsed period
          for (let d = 0; d <= Math.min(elapsedDays, 7); d++) {
            for (let h = 0; h < 24; h++) {
              // Skip if this time hasn't elapsed yet
              if (
                d > elapsedDays ||
                (d === elapsedDays && h > elapsedHoursInDay)
              )
                continue;

              // Apply noon rules
              if (d === 0 && h < 12) continue; // First day before noon
              if (d === 7 && h >= 12) continue; // Last day from noon

              if (avgData.grid[h] && avgData.grid[h][d]) {
                comparableAvgTotal += avgData.grid[h][d];
              }
            }
          }
        }

        const trendFactor =
          comparableAvgTotal > 0 ? currentData.current / comparableAvgTotal : 1;

        // Next 24 hours prediction
        const nowETComponents = getETComponents(now);
        let next24hTotal = 0;

        // Calculate for next 24 hours based on average and trend
        if (currentData.dateRange && currentData.dateRange.start) {
          // Parse start date properly
          let startDateStr;
          if (typeof currentData.dateRange.start === "string") {
            startDateStr = currentData.dateRange.start;
          } else {
            const startET = getETComponents(
              new Date(currentData.dateRange.start)
            );
            startDateStr = `${startET.year}-${String(
              startET.month + 1
            ).padStart(2, "0")}-${String(startET.day).padStart(2, "0")}`;
          }
          const startDate = parseETNoonDate(startDateStr);

          const daysSinceStart = Math.floor(
            (now - startDate) / (1000 * 60 * 60 * 24)
          );

          // Calculate current week's hourly rate
          const currentHourlyRate =
            elapsedHours > 0 ? currentData.current / elapsedHours : 0;

          // Calculate 4-week average hourly rate based on comparable period
          const avgHourlyRate =
            elapsedHours > 0 ? comparableAvgTotal / elapsedHours : 0;

          // Weighted average using configuration constants
          // This balances recent performance with historical patterns
          const weightedHourlyRate =
            currentHourlyRate * PREDICTION_WEIGHT_CURRENT +
            avgHourlyRate * PREDICTION_WEIGHT_AVERAGE;

          // For next 24 hours, use the weighted rate
          next24hTotal = weightedHourlyRate * 24;
        }

        // End of range prediction - calculate remaining hours until range ends
        let weekEndTotal = currentData.current; // Start with current total

        if (
          currentData.dateRange &&
          currentData.dateRange.end &&
          currentData.dateRange.start
        ) {
          // Parse end date properly
          let endYYYYMMDD;
          if (typeof currentData.dateRange.end === "string") {
            endYYYYMMDD = currentData.dateRange.end;
          } else {
            const endET = getETComponents(new Date(currentData.dateRange.end));
            endYYYYMMDD = `${endET.year}-${String(endET.month + 1).padStart(
              2,
              "0"
            )}-${String(endET.day).padStart(2, "0")}`;
          }
          // Use common function to get ET noon
          const endDate = parseETNoonDate(endYYYYMMDD);

          const hoursRemaining = Math.max(
            0,
            (endDate - now) / (1000 * 60 * 60)
          );

          if (hoursRemaining > 0 && elapsedHours > 0) {
            // Calculate both current and average hourly rates
            const currentHourlyRate = currentData.current / elapsedHours;
            const avgHourlyRate = comparableAvgTotal / elapsedHours;

            // Weighted average using configuration constants
            // This provides a more balanced prediction
            const weightedHourlyRate =
              currentHourlyRate * PREDICTION_WEIGHT_CURRENT +
              avgHourlyRate * PREDICTION_WEIGHT_AVERAGE;
            const predictedRemaining = weightedHourlyRate * hoursRemaining;
            weekEndTotal += predictedRemaining;
          }
        }

        // Determine trend
        let trend = "stable";
        if (trendFactor > TREND_UP_THRESHOLD)
          trend = "‚¨ÜÔ∏è Up " + Math.round((trendFactor - 1) * 100) + "%";
        else if (trendFactor < TREND_DOWN_THRESHOLD)
          trend = "‚¨áÔ∏è Down " + Math.round((1 - trendFactor) * 100) + "%";
        else trend = "‚û°Ô∏è Stable";

        return {
          pace: pace,
          next24h: Math.max(0, Math.round(next24hTotal)),
          endOfRange: Math.max(0, Math.round(weekEndTotal)),
          trend: trend,
        };
      }

      // Memoized version of 4-week average calculation
      const calculate4WeekAverageMemoized = memoize(
        function(tweets, currentStartDate, currentEndDate) {
          return calculate4WeekAverageInternal(tweets, currentStartDate, currentEndDate);
        },
        (tweets, start, end) => `avg_${start}_${end}_${tweets.length}`
      );

      // Calculate 4-week average
      function calculate4WeekAverage(tweets, currentStartDate, currentEndDate) {
        return calculate4WeekAverageMemoized(tweets, currentStartDate, currentEndDate);
      }

      function calculate4WeekAverageInternal(tweets, currentStartDate, currentEndDate) {
        if (!tweets || tweets.length === 0) return null;

        const hours = Array.from({ length: 24 }, (_, i) => formatHour(i));

        // Use same day pattern as current week (8 days, noon to noon)
        const dayNames = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"];
        let days = [];
        let start = null;

        if (currentStartDate) {
          // Use common function to create ET noon date
          start = parseETNoonDate(currentStartDate);

          // Generate same day labels as current week
          for (let i = 0; i < 8; i++) {
            // Add days and get ET components
            const currentDate = new Date(
              start.getTime() + i * 24 * 60 * 60 * 1000
            );
            const etComponents = getETComponents(currentDate);
            const dayOfWeek = etComponents.dayOfWeek;
            days.push(dayNames[dayOfWeek]);
          }
        } else {
          days = ["FRI", "SAT", "SUN", "MON", "TUE", "WED", "THU", "FRI"];
        }

        // Initialize grid for totals (8 days)
        const totals = Array(24)
          .fill()
          .map(() => Array(8).fill(0));
        const weekCounts = Array(24)
          .fill()
          .map(() => Array(8).fill(0));

        // Get tweets from last 4 weeks based on the current selected range
        // Use the actual start date from the selected range
        let currentWeekStart;
        if (currentStartDate) {
          // Use common function to create ET noon date
          currentWeekStart = parseETNoonDate(currentStartDate);
        } else {
          // Fallback to Friday if no date selected
          const now = new Date();
          currentWeekStart = new Date(now);
          while (getETComponents(currentWeekStart).dayOfWeek !== 5) {
            // Find last Friday
            currentWeekStart.setTime(
              currentWeekStart.getTime() - 24 * 60 * 60 * 1000
            );
          }
          // Set to noon ET using common function
          const weekET = getETComponents(currentWeekStart);
          const weekDateStr = `${weekET.year}-${String(
            weekET.month + 1
          ).padStart(2, "0")}-${String(weekET.day).padStart(2, "0")}`;
          currentWeekStart = parseETNoonDate(weekDateStr);
        }

        // Calculate how far we are into the current week
        const now = new Date();
        const hoursIntoCurrentWeek =
          (now - currentWeekStart) / (1000 * 60 * 60);
        const maxHours = 8 * 24; // Full week is 8 days = 192 hours
        const progressRatio = Math.min(hoursIntoCurrentWeek / maxHours, 1);

        // Pre-calculate week start noon for optimization
        const weekStartNoonCache = new Map();

        // Process each of the 4 previous weeks
        // Collect FULL week data for pattern analysis
        for (let week = 1; week <= WEEKS_FOR_TREND; week++) {
          const weekStart = new Date(currentWeekStart);
          weekStart.setTime(
            weekStart.getTime() - week * 7 * 24 * 60 * 60 * 1000
          );

          // Get full 8-day period for complete pattern
          const weekEnd = new Date(weekStart);
          weekEnd.setTime(weekEnd.getTime() + 8 * 24 * 60 * 60 * 1000);

          // Pre-calculate week start noon date once for this week
          const weekStartET = getETComponents(weekStart);
          const weekStartDateStr = `${weekStartET.year}-${String(
            weekStartET.month + 1
          ).padStart(2, "0")}-${String(weekStartET.day).padStart(2, "0")}`;
          const weekStartDayNoon = parseETNoonDate(weekStartDateStr);

          tweets.forEach((tweet) => {
            const date = parseTwitterDate(tweet.created_at);
            if (date && date >= weekStart && date < weekEnd) {
              const dateET = getETComponents(date);
              const hour = dateET.hour;

              // Calculate day position in the week pattern using ET components
              const tweetDateStr = `${dateET.year}-${String(
                dateET.month + 1
              ).padStart(2, "0")}-${String(dateET.day).padStart(2, "0")}`;

              // Check cache for this date's noon value
              let tweetDayNoon = weekStartNoonCache.get(tweetDateStr);
              if (!tweetDayNoon) {
                tweetDayNoon = parseETNoonDate(tweetDateStr);
                weekStartNoonCache.set(tweetDateStr, tweetDayNoon);
              }

              // Calculate days difference using noon times (more reliable across DST)
              const daysDiff = Math.round(
                (tweetDayNoon - weekStartDayNoon) / (1000 * 60 * 60 * 24)
              );

              if (daysDiff >= 0 && daysDiff <= 7) {
                // Include day 7 (8th day)
                // Apply noon filtering for first and last day
                if (daysDiff === 0 && hour < 12) return; // Skip first day before noon
                if (daysDiff === 7 && hour >= 12) return; // Skip last day from noon

                totals[hour][daysDiff]++;
                weekCounts[hour][daysDiff]++;
              }
            }
          });
        }

        // Calculate averages - still show full week pattern
        // but the data is based on comparable time periods
        const avgGrid = totals.map((hourRow, hourIndex) =>
          hourRow.map((total, dayIndex) => {
            // Divide by 4 to get weekly average
            return Math.round((total / 4) * 10) / 10; // Round to 1 decimal
          })
        );

        // Calculate totals excluding disabled cells
        const avgTotals = days.map((_, dayIndex) => {
          let total = 0;
          for (let hourIndex = 0; hourIndex < 24; hourIndex++) {
            // Skip disabled cells based on noon rules
            if (dayIndex === 0 && hourIndex < 12) continue; // First day before noon
            if (dayIndex === days.length - 1 && hourIndex >= 12) continue; // Last day from noon
            total += avgGrid[hourIndex][dayIndex];
          }
          return Math.round(total);
        });

        const maxValue = Math.max(...avgGrid.flat());

        return {
          grid: avgGrid,
          hours,
          days,
          totals: avgTotals,
          current: avgTotals.reduce((sum, val) => sum + val, 0),
          maxValue,
          peakHour: formatHour(
            avgGrid.findIndex((row) => row.includes(maxValue))
          ),
          mostActiveDay: days[avgTotals.indexOf(Math.max(...avgTotals))],
          dateRange: {
            start: currentStartDate, // Keep as string
            end: currentEndDate, // Keep as string
          },
        };
      }

      // Render average heatmap with requestAnimationFrame
      function renderAverageHeatmap(data) {
        requestAnimationFrame(() => {
          renderAverageHeatmapInternal(data);
        });
      }

      function renderAverageHeatmapInternal(data) {
        const container = document.getElementById("averageHeatmapContainer");

        if (!data) {
          container.innerHTML = `
            <div class="bg-gradient-to-br from-gray-50 to-blue-50 dark:from-gray-900/20 dark:to-blue-900/20 border border-gray-300 dark:border-gray-700 rounded-lg p-8 text-center">
              <div class="inline-flex items-center justify-center w-16 h-16 bg-gray-100 dark:bg-gray-900/50 rounded-full mb-4">
                <svg class="w-8 h-8 text-gray-600 dark:text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                </svg>
              </div>
              <h3 class="text-lg font-semibold text-gray-700 dark:text-gray-400 mb-2">No Historical Data</h3>
              <p class="text-sm text-gray-600 dark:text-gray-500">4-week average data is not available yet.</p>
              <p class="text-xs text-gray-500 dark:text-gray-600 mt-2">Data will appear once sufficient history is collected.</p>
            </div>
          `;
          document.getElementById("avgValue").textContent = "-";
          return;
        }

        const { grid, hours, days, totals, current, maxValue, dateRange } =
          data;

        // Batch update 4-week average indicator
        requestAnimationFrame(() => {
          const element = document.getElementById("avgValue");
          if (element) {
            element.textContent = Math.round(current).toLocaleString();
          }
        });

        let html = '<table class="w-full table-fixed border-collapse">';
        html += createColgroup(days.length);
        html += createHeatmapHeader(days);

        // Data rows
        hours.forEach((hour, hourIndex) => {
          html += '<tr class="border-b border-gray-100 dark:border-gray-800">';
          html += `<td class="bg-gray-50 dark:bg-gray-800 text-gray-600 dark:text-gray-400 font-bold px-1 py-1 text-center text-xs whitespace-nowrap border-r border-gray-200 dark:border-gray-700">${hour}</td>`;

          days.forEach((day, dayIndex) => {
            let value = grid[hourIndex][dayIndex];
            let displayValue = value > 0 ? value.toFixed(1) : "0.0";

            // Check if this cell should be disabled (noon rule applied)
            let isDisabled = isCellDisabled(
              dayIndex,
              hourIndex,
              days,
              dateRange
            );
            if (isDisabled) {
              displayValue = "-";
              value = 0;
            }

            // Check if this is the current time
            let isCurrentTime = isCurrentHour(day, hourIndex) && !isDisabled;

            let isFuture = false;

            // Get Tailwind classes for the cell - override if current time
            let cellClasses;
            let borderClasses = "border border-gray-200 dark:border-gray-700";

            if (isCurrentTime && !isDisabled) {
              // Special styling for current hour - red border
              cellClasses = getHeatmapTailwindClasses(
                value,
                maxValue,
                isDisabled,
                isFuture
              );
              borderClasses =
                "border border-red-500 dark:border-yellow-400 outline outline-2 outline-offset-[-2px] outline-red-500 dark:outline-yellow-400";
            } else {
              cellClasses = getHeatmapTailwindClasses(
                value,
                maxValue,
                isDisabled,
                isFuture
              );
            }

            let tooltipText = `${day} ${hour}: ${value.toFixed(1)} avg tweets`;
            if (isCurrentTime) {
              tooltipText += " üî¥ CURRENT HOUR";
            }

            // Determine text color based on value and state
            let textColor = "";

            // Text color based on value and state
            if (isDisabled) {
              textColor = "text-gray-400 dark:text-gray-600";
            } else if (isFuture) {
              textColor = "text-gray-400 dark:text-gray-600";
            } else if (value === 0) {
              textColor = "text-gray-600 dark:text-gray-400";
            } else if (value <= 2) {
              textColor = "text-gray-700 dark:text-gray-300";
            } else if (value <= 4) {
              textColor = "text-gray-800 dark:text-gray-200";
            } else if (value <= 7) {
              textColor = "text-gray-900 dark:text-gray-100";
            } else {
              textColor = "text-white"; // High values always white
            }

            html += `<td class="h-7 p-0 relative cursor-pointer transition-all duration-150 hover:z-10 heatmap-cell ${cellClasses} ${borderClasses}"
                        onmouseover="showTooltip(event, '${tooltipText}')"
                        onmouseout="hideTooltip()"
                        ontouchstart="handleCellTouch(event, '${tooltipText}')"
                        ontouchend="hideTooltip()"
                        data-value="${value}">`;
            html += `<span class="absolute inset-0 flex items-center justify-center text-[11px] font-semibold ${textColor} overflow-hidden pointer-events-none transition-all duration-300">${displayValue}</span>`;
            html += "</td>";
          });

          html += "</tr>";
        });

        // Totals row
        html += createTotalsRow(totals, "AVG");

        html += "</table>";

        // Use DocumentFragment for better performance
        const fragment = document.createDocumentFragment();
        const temp = document.createElement('div');
        temp.innerHTML = html;
        while (temp.firstChild) {
          fragment.appendChild(temp.firstChild);
        }
        // Smooth transition with animations
        container.style.transition = 'opacity 0.3s ease';
        container.style.opacity = '0';

        setTimeout(() => {
          container.innerHTML = '';
          container.appendChild(fragment);
          container.style.opacity = '1';

          // Animate cells
          const cells = container.querySelectorAll('.heatmap-cell');
          cells.forEach((cell, index) => {
            const value = parseInt(cell.dataset.value || 0);
            setTimeout(() => {
              cell.classList.add('fade-enter-active');
              // Add glow effect for high values
              if (value >= 10) {
                cell.classList.add('high-value-glow');
              }
            }, Math.min(index * 2, 100)); // Cap delay to prevent too long animation
          });
        }, 200);
      }

      // Render heatmap with requestAnimationFrame
      function renderHeatmap(data) {
        requestAnimationFrame(() => {
          renderHeatmapInternal(data);
        });
      }

      function renderHeatmapInternal(data) {
        const container = document.getElementById("heatmapContainer");

        if (!data) {
          // Improved empty state design
          container.style.opacity = '0';
          setTimeout(() => {
            container.innerHTML = `
              <div class="bg-gradient-to-br from-red-50 to-orange-50 dark:from-red-900/20 dark:to-orange-900/20 border border-red-300 dark:border-red-700 rounded-lg p-8 text-center">
                <div class="inline-flex items-center justify-center w-16 h-16 bg-red-100 dark:bg-red-900/50 rounded-full mb-4">
                  <svg class="w-8 h-8 text-red-600 dark:text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                  </svg>
                </div>
                <h3 class="text-lg font-semibold text-red-700 dark:text-red-400 mb-2">Unable to Process Data</h3>
                <p class="text-sm text-red-600 dark:text-red-500 mb-4">The tweet data could not be processed at this time.</p>
                <button onclick="handleButtonClick(event, () => loadData(true))" class="px-4 py-2 bg-red-600 hover:bg-red-700 dark:bg-red-500 dark:hover:bg-red-600 text-white rounded-md font-semibold transition-all duration-200 transform active:scale-95">
                  Try Again
                </button>
              </div>
            `;
            container.style.opacity = '1';
          }, 200);
          return;
        }

        const {
          grid,
          hours,
          days,
          totals,
          current,
          maxValue,
          peakHour,
          mostActiveDay,
          dateRange,
        } = data;

        // Batch DOM updates to minimize reflows
        requestAnimationFrame(() => {
          const updates = [
            { id: "currentValue", value: current.toLocaleString() },
            { id: "peakHour", value: peakHour },
            { id: "mostActiveDay", value: mostActiveDay }
          ];

          // Batch all reads first, then writes
          const elements = new Map();
          updates.forEach(({ id }) => {
            elements.set(id, document.getElementById(id));
          });

          // Then batch all writes
          updates.forEach(({ id, value }) => {
            const element = elements.get(id);
            if (element) element.textContent = value;
          });
        });

        let html = '<table class="w-full table-fixed border-collapse">';
        html += createColgroup(days.length);
        html += createHeatmapHeader(days);

        // Data rows
        hours.forEach((hour, hourIndex) => {
          html += '<tr class="border-b border-gray-100 dark:border-gray-800">';
          html += `<td class="bg-gray-50 dark:bg-gray-800 text-gray-600 dark:text-gray-400 font-bold px-1 py-1 text-center text-xs whitespace-nowrap border-r border-gray-200 dark:border-gray-700">${hour}</td>`;

          days.forEach((day, dayIndex) => {
            let value = grid[hourIndex][dayIndex];
            let displayValue = value >= 0 ? value : ""; // Show 0 instead of empty

            // Check if this cell should be disabled (noon rule applied)
            let isDisabled = isCellDisabled(
              dayIndex,
              hourIndex,
              days,
              dateRange
            );
            if (isDisabled) {
              displayValue = "-";
              value = 0; // Set value to 0 for disabled cells
            }

            // Check if this is the current time or future time
            let isCurrentTime = isCurrentHour(day, hourIndex) && !isDisabled;
            let isFuture = false;

            isFuture = isFutureTime(dateRange, dayIndex, hourIndex);

            // Apply future style if needed
            if (isFuture && !isDisabled) {
              displayValue = ""; // Empty for future
            }

            // Get Tailwind classes for the cell
            let cellClasses = getHeatmapTailwindClasses(
              value,
              maxValue,
              isDisabled,
              isFuture
            );
            let borderClasses = "border border-gray-200 dark:border-gray-700";

            // Special styling for current hour
            if (isCurrentTime && !isDisabled) {
              borderClasses =
                "border border-red-500 dark:border-yellow-400 outline outline-2 outline-offset-[-2px] outline-red-500 dark:outline-yellow-400";
            }

            // Create tooltip with actual date if available
            let tooltipText = `${day} ${hour}: ${value} tweets`;
            if (dateRange && dateRange.start) {
              // Use parseETNoonDate to properly handle the date
              let startDateStr;
              if (typeof dateRange.start === "string") {
                startDateStr = dateRange.start;
              } else {
                const startET = getETComponents(new Date(dateRange.start));
                startDateStr = `${startET.year}-${String(
                  startET.month + 1
                ).padStart(2, "0")}-${String(startET.day).padStart(2, "0")}`;
              }

              const startDate = parseETNoonDate(startDateStr);
              const cellDate = new Date(
                startDate.getTime() + dayIndex * 24 * 60 * 60 * 1000
              );
              const cellET = getETComponents(cellDate);

              // Format date in ET
              const monthNames = [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec",
              ];
              const dateStr = `${monthNames[cellET.month]} ${cellET.day}`;

              if (isFuture && !isDisabled) {
                tooltipText = `${dateStr} (${day}) ${hour}: Future`;
              } else {
                tooltipText = `${dateStr} (${day}) ${hour}: ${value} tweets`;
              }

              if (isCurrentTime) {
                tooltipText += " üî¥ CURRENT HOUR";
              }
            }

            // Determine text color based on value and state
            let textColor = "";

            // Text color based on value and state
            if (isDisabled) {
              textColor = "text-gray-400 dark:text-gray-600";
            } else if (isFuture) {
              textColor = "text-gray-400 dark:text-gray-600";
            } else if (value === 0) {
              textColor = "text-gray-600 dark:text-gray-400";
            } else if (value <= 2) {
              textColor = "text-gray-700 dark:text-gray-300";
            } else if (value <= 4) {
              textColor = "text-gray-800 dark:text-gray-200";
            } else if (value <= 7) {
              textColor = "text-gray-900 dark:text-gray-100";
            } else {
              textColor = "text-white"; // High values always white
            }

            html += `<td class="h-7 p-0 relative cursor-pointer transition-all duration-150 hover:z-10 heatmap-cell ${cellClasses} ${borderClasses}"
                        onmouseover="showTooltip(event, '${tooltipText}')"
                        onmouseout="hideTooltip()"
                        ontouchstart="handleCellTouch(event, '${tooltipText}')"
                        ontouchend="hideTooltip()"
                        data-value="${value}">`;
            html += `<span class="absolute inset-0 flex items-center justify-center text-[11px] font-semibold ${textColor} overflow-hidden pointer-events-none transition-all duration-300">${displayValue}</span>`;
            html += "</td>";
          });

          html += "</tr>";
        });

        // Totals row
        html += createTotalsRow(totals, "TOTALS");

        html += "</table>";

        // Use DocumentFragment for better performance
        const fragment = document.createDocumentFragment();
        const temp = document.createElement('div');
        temp.innerHTML = html;
        while (temp.firstChild) {
          fragment.appendChild(temp.firstChild);
        }
        // Smooth transition with animations
        container.style.transition = 'opacity 0.3s ease';
        container.style.opacity = '0';

        setTimeout(() => {
          container.innerHTML = '';
          container.appendChild(fragment);
          container.style.opacity = '1';

          // Animate cells
          const cells = container.querySelectorAll('.heatmap-cell');
          cells.forEach((cell, index) => {
            const value = parseInt(cell.dataset.value || 0);
            setTimeout(() => {
              cell.classList.add('fade-enter-active');
              // Add glow effect for high values
              if (value >= 10) {
                cell.classList.add('high-value-glow');
              }
            }, Math.min(index * 2, 100)); // Cap delay to prevent too long animation
          });
        }, 200);
      }

      // Track if data is currently loading
      let isLoadingData = false;

      // Debounce helper function
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Request queue to prevent duplicate API calls
      const requestQueue = new Map();

      // Memoization cache for expensive calculations
      const memoCache = new Map();
      const MEMO_CACHE_MAX = 50;

      // Generic memoization function
      function memoize(fn, keyGenerator) {
        return function(...args) {
          const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);

          if (memoCache.has(key)) {
            debugLog('Returning memoized result for:', key);
            return memoCache.get(key);
          }

          // LRU cache eviction
          if (memoCache.size >= MEMO_CACHE_MAX) {
            const firstKey = memoCache.keys().next().value;
            memoCache.delete(firstKey);
          }

          const result = fn.apply(this, args);
          memoCache.set(key, result);
          return result;
        };
      }

      // Cache Module - Handles localStorage caching
      const Cache = {
        CACHE_KEY: 'elonTrackerCache',
        CACHE_EXPIRY: 24 * 60 * 60 * 1000, // 24 hours

        save(tweets) {
          try {
            const cacheData = {
              tweets: tweets,
              timestamp: Date.now(),
              lastUpdate: new Date().toISOString()
            };
            localStorage.setItem(this.CACHE_KEY, JSON.stringify(cacheData));
            debugLog("Data cached successfully");
          } catch (error) {
            debugLog("Failed to cache data:", error);
          }
        },

        load() {
          try {
            const cached = localStorage.getItem(this.CACHE_KEY);
            if (!cached) return null;

            const cacheData = JSON.parse(cached);
            const age = Date.now() - cacheData.timestamp;

            // Return cache if less than 24 hours old
            if (age < this.CACHE_EXPIRY) {
              debugLog(`Loading cached data (${Math.round(age / 1000 / 60)} minutes old)`);
              return cacheData;
            }

            debugLog("Cache expired, will fetch new data");
            return null;
          } catch (error) {
            debugLog("Failed to load cache:", error);
            return null;
          }
        },

        clear() {
          localStorage.removeItem(this.CACHE_KEY);
        }
      };

      // API Module - Handles all API interactions
      const API = {
        async fetchTweetData() {
          const requestKey = 'tweet-data';

          // Check if request is already in progress
          if (requestQueue.has(requestKey)) {
            debugLog('Returning existing request promise');
            return requestQueue.get(requestKey);
          }

          // Create new request promise
          const requestPromise = fetch(
            "https://corsproxy.io/?https://www.xtracker.io/api/download",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ handle: "elonmusk", platform: "X" }),
              signal: AbortSignal.timeout(30000) // 30 second timeout
            }
          ).then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.text();
          }).finally(() => {
            // Clean up request from queue
            requestQueue.delete(requestKey);
          });

          // Store in queue
          requestQueue.set(requestKey, requestPromise);
          return requestPromise;
        },

        validateCSVData(csvText) {
          if (
            !csvText.includes("id,text,created_at") &&
            !csvText.includes("created_at")
          ) {
            throw new Error("Invalid CSV format");
          }
          return true;
        },
      };

      // UI Module - Handles UI updates
      const UI = {
        showSkeletonLoader(containerId) {
          const container = document.getElementById(containerId);
          if (container) {
            let html = `
              <div class="bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-900 dark:to-gray-800 rounded-lg p-6">
                <div class="animate-pulse">
                  <div class="flex items-center justify-center mb-4">
                    <div class="h-2 bg-gray-300 dark:bg-gray-700 rounded w-32 shimmer"></div>
                  </div>
                  <table class="w-full table-fixed border-collapse">
            `;

            // Skeleton header
            html += '<tr class="border-b border-gray-200 dark:border-gray-700">';
            html += '<th class="h-7 bg-gray-200 dark:bg-gray-700 rounded shimmer"></th>';
            for (let i = 0; i < 8; i++) {
              html += '<th class="h-7 bg-gray-200 dark:bg-gray-700 rounded mx-1 shimmer"></th>';
            }
            html += '</tr>';

            // Skeleton rows
            for (let h = 0; h < 24; h++) {
              html += '<tr class="border-b border-gray-100 dark:border-gray-800">';
              html += '<td class="h-7 bg-gray-200 dark:bg-gray-700 rounded my-1 shimmer"></td>';
              for (let d = 0; d < 8; d++) {
                const delay = (h * 8 + d) * 50;
                html += `<td class="h-7 bg-gray-200 dark:bg-gray-700 rounded m-1 shimmer" style="animation-delay: ${delay}ms"></td>`;
              }
              html += '</tr>';
            }

            html += `
                  </table>
                </div>
                <div class="text-center mt-4">
                  <p class="text-sm text-gray-500 dark:text-gray-400 animate-pulse">Loading tweet data...</p>
                </div>
              </div>
            `;
            container.innerHTML = html;
          }
        },

        showLoadingIndicator(containerId, message) {
          const container = document.getElementById(containerId);
          if (container) {
            container.innerHTML = `
              <div class="flex items-center justify-center p-8 text-gray-600 dark:text-gray-400">
                <div class="text-center">
                  <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 dark:border-blue-400 mb-4"></div>
                  <div>${message}</div>
                </div>
              </div>
            `;
          }
        },

        showError(containerId, message, details = null) {
          const container = document.getElementById(containerId);
          if (container) {
            let html = `
              <div class="bg-red-50 dark:bg-red-900/20 border border-red-300 dark:border-red-700 rounded-lg p-6">
                <div class="flex items-start">
                  <div class="flex-shrink-0">
                    <svg class="h-6 w-6 text-red-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                  </div>
                  <div class="ml-3">
                    <h3 class="text-sm font-medium text-red-800 dark:text-red-400">
                      ${message}
                    </h3>
                    ${details ? `
                      <div class="mt-2 text-sm text-red-700 dark:text-red-500">
                        ${details}
                      </div>
                    ` : ''}
                  </div>
                </div>
              </div>
            `;
            container.innerHTML = html;
          }
        },

        updateButton(selector, text, disabled = false) {
          const btn = document.querySelector(selector);
          if (btn) {
            btn.disabled = disabled;
            btn.textContent = text;
            if (disabled) {
              btn.classList.add("opacity-60", "cursor-not-allowed");
            } else {
              btn.classList.remove("opacity-60", "cursor-not-allowed");
            }
          }
        },

        updateIndicator(id, value) {
          requestAnimationFrame(() => {
            const element = document.getElementById(id);
            if (element) {
              element.textContent = value;
            }
          });
        },
      };

      // Debounced load data function
      const debouncedLoadData = debounce(async function(forceRefresh = false) {
        await loadDataInternal(forceRefresh);
      }, 500); // 500ms debounce

      // Load data from X Tracker API
      async function loadData(forceRefresh = false) {
        // Use debounced version for manual triggers
        if (!forceRefresh) {
          debouncedLoadData(forceRefresh);
        } else {
          // For force refresh, call directly
          await loadDataInternal(forceRefresh);
        }
      }

      async function loadDataInternal(forceRefresh = false) {
        // Skip if already loading
        if (isLoadingData) {
          debugLog("Skipping loadData - already loading");
          return;
        }

        isLoadingData = true;
        const container = document.getElementById("heatmapContainer");

        // Try to load from cache first if not forcing refresh
        if (!forceRefresh) {
          const cachedData = Cache.load();
          if (cachedData && cachedData.tweets) {
            debugLog(`Using cached data (${Math.round((Date.now() - cachedData.timestamp) / 1000 / 60)} minutes old)`);

            // Process cached data
            rawTweets = cachedData.tweets;
            populateWeekRanges(cachedData.tweets);

            const { startDate, endDate, type } = getSelectedDateRange();
            currentData = processData(cachedData.tweets, startDate, endDate, type);
            renderHeatmap(currentData);

            const avgData = calculate4WeekAverage(cachedData.tweets, startDate, endDate);
            renderAverageHeatmap(avgData);

            const predictions = calculatePredictions(currentData, avgData);
            UI.updateIndicator("currentPace", predictions.pace);
            UI.updateIndicator("next24hPrediction", predictions.next24h.toLocaleString() + " tweets");
            UI.updateIndicator("weekEndPrediction", predictions.endOfRange.toLocaleString() + " tweets");
            UI.updateIndicator("trendIndicator", predictions.trend);

            // Update last refresh time with cache age indicator
            const lastUpdatedElement = document.getElementById("lastUpdated");
            if (lastUpdatedElement) {
              const cacheDate = new Date(cachedData.timestamp);
              const timeString = cacheDate.toLocaleTimeString("en-US", {
                hour12: true,
                hour: "numeric",
                minute: "2-digit",
                second: "2-digit",
              });
              const ageMinutes = Math.round((Date.now() - cachedData.timestamp) / 1000 / 60);
              lastUpdatedElement.innerHTML = `${timeString} <span class="text-xs text-gray-500 dark:text-gray-400">(${ageMinutes}m ago)</span>`;
            }

            startRefreshCountdown();
            isLoadingData = false;

            // Fetch fresh data in background
            setTimeout(() => loadDataInternal(true), 1000);
            return;
          }
        }

        // Disable the update button
        UI.updateButton('button[onclick="loadData()"]', "üîÑ Updating...", true);

        // Show loading progress
        const updateIndicator = document.getElementById("lastUpdated");
        const originalText = updateIndicator ? updateIndicator.textContent : "";
        if (updateIndicator) {
          updateIndicator.innerHTML = `<span class="inline-block animate-spin rounded-full h-3 w-3 border-b-2 border-blue-500 dark:border-blue-300 mr-2"></span>Fetching data...`;
          updateIndicator.classList.remove(
            "text-gray-900",
            "dark:text-gray-100"
          ); // Remove default colors
          updateIndicator.classList.add("text-blue-600", "dark:text-blue-300");
        }

        try {
          debugLog("Fetching tweet data from API...");
          const csvText = await API.fetchTweetData();

          // Validate CSV data
          API.validateCSVData(csvText);

          // Parse last 5 weeks of data
          const tweets = parseCSV(csvText, 5);

          if (tweets.length === 0) {
            throw new Error("No valid tweets found");
          }

          debugLog(`Successfully loaded ${tweets.length} tweets`);

          // Store raw tweets for future use
          rawTweets = tweets;

          // Cache the successful data
          Cache.save(tweets);

          // Populate week ranges on first successful load
          populateWeekRanges(tweets);

          const { startDate, endDate, type } = getSelectedDateRange();
          debugLog("Selected date range:", { startDate, endDate, type });

          currentData = processData(tweets, startDate, endDate, type);
          debugLog("Current data processed:", currentData);

          renderHeatmap(currentData);
          debugLog("Heatmap rendered");

          // Calculate and render 4-week average
          const avgData = calculate4WeekAverage(tweets, startDate, endDate);
          debugLog("4-week average calculated:", avgData);

          renderAverageHeatmap(avgData);
          debugLog("Average heatmap rendered");

          // Calculate and display predictions (batched)
          const predictions = calculatePredictions(currentData, avgData);
          requestAnimationFrame(() => {
            const updates = [
              { id: "currentPace", value: predictions.pace },
              { id: "next24hPrediction", value: predictions.next24h.toLocaleString() + " tweets" },
              { id: "weekEndPrediction", value: predictions.endOfRange.toLocaleString() + " tweets" },
              { id: "trendIndicator", value: predictions.trend }
            ];

            // Batch DOM updates
            updates.forEach(({ id, value }) => {
              const element = document.getElementById(id);
              if (element) element.textContent = value;
            });
          });

          // Update last refresh time and start countdown
          updateLastRefreshTime();
          startRefreshCountdown();

          // Reset the update indicator color
          if (updateIndicator) {
            updateIndicator.classList.remove(
              "text-blue-600",
              "dark:text-blue-300"
            );
            updateIndicator.classList.add(
              "text-gray-900",
              "dark:text-gray-100"
            );
          }

          // Re-enable the update button
          UI.updateButton(
            'button[onclick="loadData()"]',
            "üîÑ Update Now",
            false
          );

          // Reset loading flag
          isLoadingData = false;
        } catch (error) {
          console.error("Failed to load data:", error);
          debugLog("Error details:", error.message, error.stack);

          // Determine error type for better user feedback
          const errorMessage =
            error && error.message ? error.message : "Unknown error";

          let errorType = "Unknown Error";
          let errorDetails = "";
          let errorSolution = "";

          if (errorMessage.includes("fetch") || errorMessage.includes("Failed to fetch") || errorMessage.includes("network")) {
            errorType = "Network Connection Error";
            errorDetails = "Unable to connect to the X Tracker API. This could be due to network issues or CORS restrictions.";
            errorSolution = "Try refreshing the page, check your internet connection, or use a CORS extension.";
          } else if (errorMessage.includes("404")) {
            errorType = "API Not Found";
            errorDetails = "The X Tracker API endpoint could not be found. The service may have moved or changed.";
            errorSolution = "Please check if the API is still available or use the CSV upload option.";
          } else if (errorMessage.includes("500") || errorMessage.includes("502") || errorMessage.includes("503")) {
            errorType = "Server Error";
            errorDetails = "The X Tracker API server is experiencing issues.";
            errorSolution = "Please wait a few minutes and try again. The service may be temporarily down.";
          } else if (errorMessage.includes("Invalid CSV") || errorMessage.includes("No valid tweets")) {
            errorType = "Data Format Error";
            errorDetails = "The data received from the API is not in the expected format.";
            errorSolution = "The API format may have changed. Try uploading a CSV file manually.";
          } else if (errorMessage.includes("timeout")) {
            errorType = "Request Timeout";
            errorDetails = "The request took too long to complete.";
            errorSolution = "Check your internet connection speed and try again.";
          }

          // Reset the update indicator with specific error
          if (updateIndicator) {
            updateIndicator.innerHTML = `<span class="text-red-600 dark:text-red-400">‚ö†Ô∏è ${errorType}</span>`;
            updateIndicator.classList.remove(
              "text-blue-600",
              "dark:text-blue-300",
              "text-gray-900",
              "dark:text-gray-100"
            );
          }

          // Re-enable the update button
          UI.updateButton(
            'button[onclick="loadData()"]',
            "üîÑ Update Now",
            false
          );

          // Reset loading flag
          isLoadingData = false;

          // Only show error if no previous data exists
          if (!container.querySelector("table")) {
            container.innerHTML = `
               <div class="bg-red-50 dark:bg-red-900/20 border border-red-300 dark:border-red-700 rounded-lg p-6">
                 <div class="flex items-start mb-4">
                   <div class="flex-shrink-0">
                     <svg class="h-8 w-8 text-red-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                       <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                     </svg>
                   </div>
                   <div class="ml-3 flex-1">
                     <h3 class="text-lg font-semibold text-red-700 dark:text-red-400">${errorType}</h3>
                     <p class="text-sm text-red-600 dark:text-red-500 mt-1">${errorDetails}</p>
                     ${errorSolution ? `<p class="text-sm text-gray-600 dark:text-gray-400 mt-2">üí° ${errorSolution}</p>` : ''}
                   </div>
                 </div>
                 <div class="bg-white dark:bg-gray-800 rounded-lg p-4 mt-4">
                   <h4 class="font-semibold text-gray-700 dark:text-gray-300 mb-3">Alternative Solutions:</h4>
                   <ul class="text-left space-y-2 mb-4 text-sm text-gray-600 dark:text-gray-400">
                     <li class="flex items-start">
                       <span class="mr-2">üîÑ</span>
                       <span>Wait a few minutes and retry (API might be temporarily down)</span>
                     </li>
                     <li class="flex items-start">
                       <span class="mr-2">üìÅ</span>
                       <span>Upload a CSV file downloaded from <a href="https://www.xtracker.io/api/download" target="_blank" class="text-blue-600 dark:text-blue-400 hover:underline">X Tracker</a></span>
                     </li>
                     <li class="flex items-start">
                       <span class="mr-2">üîß</span>
                       <span>Install a CORS browser extension like "CORS Unblock" or "CORS Everywhere"</span>
                     </li>
                     <li class="flex items-start">
                       <span class="mr-2">üîó</span>
                       <span>Open <a href="https://www.xtracker.io/api/download" target="_blank" class="text-blue-600 dark:text-blue-400 hover:underline">this link</a>, save as CSV, then upload</span>
                     </li>
                   </ul>
                   <div class="my-4 border-t border-gray-200 dark:border-gray-700 pt-4">
                     <label for="csvFileInput" class="block font-semibold text-gray-700 dark:text-gray-300 mb-2">Upload CSV File:</label>
                     <input type="file" id="csvFileInput" accept=".csv" class="block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:border-blue-500 dark:hover:border-blue-400 transition-colors" onchange="handleFileUpload(event)">
                   </div>
                   <div class="mt-4 flex gap-2">
                     <button onclick="handleButtonClick(event, () => loadData(true))" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 text-white rounded-md font-semibold transition-all duration-200 transform active:scale-95">üîÑ Retry API</button>
                     <button onclick="handleButtonClick(event, () => { Cache.clear(); location.reload(); })" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 dark:bg-gray-500 dark:hover:bg-gray-600 text-white rounded-md font-semibold transition-all duration-200 transform active:scale-95">üóëÔ∏è Clear Cache</button>
                   </div>
                 </div>
               </div>
             `;
          }
        }
      }

      // Download current data as CSV
      function downloadCSV() {
        if (!currentData) {
          alert("No data available to download");
          return;
        }

        // Create CSV content
        let csvContent =
          "Hour,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday\n";

        currentData.hours.forEach((hour, hourIndex) => {
          const row = [hour, ...currentData.grid[hourIndex]];
          csvContent += row.join(",") + "\n";
        });

        // Add totals row
        csvContent += "TOTALS," + currentData.totals.join(",") + "\n";

        // Create and download file
        const blob = new Blob([csvContent], { type: "text/csv" });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "elon-tweet-heatmap.csv";
        a.click();
        window.URL.revokeObjectURL(url);
      }

      // Generate specific date ranges based on pattern (deprecated - not used anymore)
      function generateWeekRanges(tweets) {
        // This function is no longer used
        // Date ranges are now generated dynamically in populateWeekRanges()
        return [];
      }

      // Populate week range dropdown
      function populateWeekRanges(tweets = null) {
        const select = document.getElementById("weekRange");

        // Save current selection before clearing
        const currentSelection = select.value;

        // Clear existing options
        select.innerHTML = '<option value="">Select a week range...</option>';

        if (!tweets || tweets.length === 0) {
          return;
        }

        // Find date range from actual tweet data
        const dates = [];
        tweets.forEach((tweet) => {
          const date = parseTwitterDate(tweet.created_at);
          if (date) {
            dates.push(date);
          }
        });

        if (dates.length === 0) return;

        // Sort dates
        dates.sort((a, b) => a - b);

        // Get min and max dates
        const minDate = dates[0];
        const maxDate = dates[dates.length - 1];

        // Generate weekly ranges based on actual data
        const ranges = [];
        const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

        // Generate both Friday-to-Friday and Tuesday-to-Tuesday ranges
        const specificRanges = [];
        const currentDate = new Date();

        // Get current time in ET for comparison
        const currentET = getETComponents(currentDate);

        // Find the most recent Friday in ET
        let recentFriday = new Date(currentDate);
        while (getETComponents(recentFriday).dayOfWeek !== 5) {
          // 5 = Friday
          recentFriday.setTime(recentFriday.getTime() - 24 * 60 * 60 * 1000);
        }

        // Find the most recent Tuesday in ET
        let recentTuesday = new Date(currentDate);
        while (getETComponents(recentTuesday).dayOfWeek !== 2) {
          // 2 = Tuesday
          recentTuesday.setTime(recentTuesday.getTime() - 24 * 60 * 60 * 1000);
        }

        // Add current ongoing week ranges
        // Friday range - check if we're past Friday noon ET
        let startFriday = new Date(recentFriday);
        let endFriday = new Date(recentFriday);
        endFriday.setTime(endFriday.getTime() + 7 * 24 * 60 * 60 * 1000);

        // If we're on Friday and past noon ET, move to next week's range
        if (currentET.dayOfWeek === 5 && currentET.hour >= 12) {
          startFriday.setTime(startFriday.getTime() + 7 * 24 * 60 * 60 * 1000);
          endFriday.setTime(endFriday.getTime() + 7 * 24 * 60 * 60 * 1000);
        }

        specificRanges.push({
          start: new Date(startFriday),
          end: new Date(endFriday),
          type: "friday",
        });

        // Tuesday range - check if we're past Tuesday noon ET
        let startTuesday = new Date(recentTuesday);
        let endTuesday = new Date(recentTuesday);
        endTuesday.setTime(endTuesday.getTime() + 7 * 24 * 60 * 60 * 1000);

        // If we're on Tuesday and past noon ET, move to next week's range
        if (currentET.dayOfWeek === 2 && currentET.hour >= 12) {
          startTuesday.setTime(
            startTuesday.getTime() + 7 * 24 * 60 * 60 * 1000
          );
          endTuesday.setTime(endTuesday.getTime() + 7 * 24 * 60 * 60 * 1000);
        }

        specificRanges.push({
          start: new Date(startTuesday),
          end: new Date(endTuesday),
          type: "tuesday",
        });

        // Generate past ranges for both Friday and Tuesday
        let pastFriday = new Date(recentFriday);
        let pastTuesday = new Date(recentTuesday);

        // Go back 8 weeks for each pattern
        for (let i = 0; i < 8; i++) {
          // Friday ranges
          const endFridayPast = new Date(pastFriday);
          pastFriday = new Date(pastFriday);
          pastFriday.setTime(pastFriday.getTime() - 7 * 24 * 60 * 60 * 1000);

          if (pastFriday >= minDate && pastFriday <= maxDate) {
            specificRanges.push({
              start: new Date(pastFriday),
              end: new Date(endFridayPast),
              type: "friday",
            });
          }

          // Tuesday ranges
          const endTuesdayPast = new Date(pastTuesday);
          pastTuesday = new Date(pastTuesday);
          pastTuesday.setTime(pastTuesday.getTime() - 7 * 24 * 60 * 60 * 1000);

          if (pastTuesday >= minDate && pastTuesday <= maxDate) {
            specificRanges.push({
              start: new Date(pastTuesday),
              end: new Date(endTuesdayPast),
              type: "tuesday",
            });
          }
        }

        // Sort ranges by start date (most recent first)
        specificRanges.sort((a, b) => b.start - a.start);

        // Process each range - only include ranges that have started (noon ET on start date)
        specificRanges.forEach((range) => {
          // Check if the range has started (noon ET on start date)
          // Get ET components and create YYYY-MM-DD string
          const startET = getETComponents(range.start);
          const startYear = startET.year;
          const startMonth = String(startET.month + 1).padStart(2, "0");
          const startDayNum = String(startET.day).padStart(2, "0");
          const startDateStr = `${startYear}-${startMonth}-${startDayNum}`;

          // Use common function to create ET noon date
          const rangeStartNoon = parseETNoonDate(startDateStr);

          // Current time
          const now = new Date();

          // Only include ranges where start date noon has passed
          if (rangeStartNoon <= now) {
            // Get day of week in ET timezone
            const endET = getETComponents(range.end);
            const startDay = dayNames[startET.dayOfWeek];
            const endDay = dayNames[endET.dayOfWeek];

            // Use ET date components to avoid timezone issues
            // startDateStr already created above
            const endYear = endET.year;
            const endMonth = String(endET.month + 1).padStart(2, "0");
            const endDayNum = String(endET.day).padStart(2, "0");
            const endStr = `${endYear}-${endMonth}-${endDayNum}`;

            const startLabel = range.start.toLocaleDateString("en-US", {
              month: "long",
              day: "numeric",
            });
            const endLabel = range.end.toLocaleDateString("en-US", {
              month: "long",
              day: "numeric",
            });

            ranges.push({
              value: `${startDateStr}|${endStr}|${startDay.toLowerCase()}`,
              display: `${startLabel} - ${endLabel} (${startDay}-${endDay})`,
              startDate: startDateStr,
              endDate: endStr,
              endDateTime: range.end,
            });
          }
        });

        // Sort ranges by start date in descending order (most recent first)
        ranges.sort((a, b) => {
          const dateA = new Date(a.startDate);
          const dateB = new Date(b.startDate);
          return dateB - dateA;
        });

        // Add all ranges to dropdown
        ranges.forEach((range) => {
          const option = document.createElement("option");
          option.value = range.value;
          option.textContent = range.display;
          select.appendChild(option);
        });

        // Find the ongoing range with the earliest end date (will end soonest)
        const now = new Date();
        let earliestEndingOngoingIndex = -1;
        let earliestEndDate = null;

        ranges.forEach((range, index) => {
          // Check if this range is ongoing (end date ET noon hasn't passed)
          // Use common function to create ET noon date
          const endDateNoon = parseETNoonDate(range.endDate);

          if (endDateNoon > now) {
            // This range is ongoing
            if (!earliestEndDate || endDateNoon < earliestEndDate) {
              // This is the earliest ending ongoing range so far
              earliestEndDate = endDateNoon;
              earliestEndingOngoingIndex = index + 1; // +1 for the "Select a week range..." option
            }
          }
        });

        // Restore previous selection if it exists, otherwise use default
        let selectionRestored = false;

        if (currentSelection) {
          // Try to restore the previous selection
          for (let i = 0; i < select.options.length; i++) {
            if (select.options[i].value === currentSelection) {
              select.options[i].selected = true;
              selectionRestored = true;
              break;
            }
          }
        }

        // If no previous selection or it doesn't exist anymore, use default
        if (!selectionRestored) {
          if (earliestEndingOngoingIndex > 0) {
            select.options[earliestEndingOngoingIndex].selected = true;
          } else if (ranges.length > 0) {
            // If all ranges are completed, select the most recent
            select.options[1].selected = true;
          }
        }
      }

      // Update date range when dropdown changes
      function updateDateRange() {
        const select = document.getElementById("weekRange");
        const selectedValue = select.value;

        // Haptic feedback for dropdown change
        if (isMobileDevice()) {
          triggerHaptic('light');
        }

        if (selectedValue && rawTweets) {
          debugLog("Reprocessing data for new date range...");

          const { startDate, endDate, type } = getSelectedDateRange();
          currentData = processData(rawTweets, startDate, endDate, type);
          renderHeatmap(currentData);

          // Recalculate 4-week average
          const avgData = calculate4WeekAverage(rawTweets, startDate, endDate);
          renderAverageHeatmap(avgData);

          // Recalculate predictions
          const predictions = calculatePredictions(currentData, avgData);
          document.getElementById("currentPace").textContent = predictions.pace;
          document.getElementById("next24hPrediction").textContent =
            predictions.next24h.toLocaleString() + " tweets";
          document.getElementById("weekEndPrediction").textContent =
            predictions.endOfRange.toLocaleString() + " tweets";
          document.getElementById("trendIndicator").textContent =
            predictions.trend;
        } else if (selectedValue) {
          // If no raw data available, load from API
          loadData();
        }
      }

      // Get selected date range
      function getSelectedDateRange() {
        const select = document.getElementById("weekRange");
        const selectedValue = select.value;

        if (selectedValue) {
          const parts = selectedValue.split("|");
          const [startDate, endDate] = parts;
          const type = parts[2] || "friday"; // Default to friday if not specified
          return { startDate, endDate, type };
        }

        return { startDate: null, endDate: null, type: null };
      }

      // Handle file upload
      function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const csvText = e.target.result;
            // Parse last 5 weeks of data
            const tweets = parseCSV(csvText, 5);

            if (tweets.length === 0) {
              alert("No valid tweets found in the uploaded file");
              return;
            }

            debugLog(`Loaded ${tweets.length} tweets from uploaded file`);

            // Populate week ranges when file is uploaded
            populateWeekRanges(tweets);

            const { startDate, endDate, type } = getSelectedDateRange();
            currentData = processData(tweets, startDate, endDate, type);
            renderHeatmap(currentData);

            // Calculate and render 4-week average
            const avgData = calculate4WeekAverage(tweets, startDate, endDate);
            renderAverageHeatmap(avgData);

            // Calculate and display predictions
            const predictions = calculatePredictions(currentData, avgData);
            document.getElementById("currentPace").textContent =
              predictions.pace;
            document.getElementById("next24hPrediction").textContent =
              predictions.next24h.toLocaleString() + " tweets";
            document.getElementById("weekEndPrediction").textContent =
              predictions.endOfRange.toLocaleString() + " tweets";
            document.getElementById("trendIndicator").textContent =
              predictions.trend;
          } catch (error) {
            alert("Error parsing CSV file: " + error.message);
          }
        };

        reader.readAsText(file);
      }

      // Auto refresh functions
      function toggleAutoRefresh() {
        const btn = document.getElementById("autoRefreshBtn");
        const countdownIndicator = document.getElementById(
          "refreshCountdownIndicator"
        );

        if (isAutoRefreshEnabled) {
          // Disable auto refresh
          isAutoRefreshEnabled = false;
          if (autoRefreshInterval) {
            clearInterval(autoRefreshInterval);
            autoRefreshInterval = null;
          }
          if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
          }
          btn.textContent = "‚è∞ Auto Refresh: OFF";
          btn.className =
            "px-3 py-1.5 text-sm bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 rounded-md font-bold transition-all duration-200 transform active:scale-95";
          countdownIndicator.classList.add("hidden");
        } else {
          // Enable auto refresh
          isAutoRefreshEnabled = true;
          autoRefreshInterval = setInterval(() => {
            if (!isLoadingData) {
              debugLog("Auto refreshing data...");
              loadData();
            } else {
              debugLog("Skipping auto refresh - already loading");
            }
          }, AUTO_REFRESH_INTERVAL);

          btn.textContent = "‚è∞ Auto Refresh: ON";
          btn.className =
            "px-3 py-1.5 text-sm bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 text-white rounded-md font-bold transition-all duration-200 transform active:scale-95";
          countdownIndicator.classList.remove("hidden");
          startRefreshCountdown();
        }
      }

      function startRefreshCountdown() {
        if (!isAutoRefreshEnabled) return;

        refreshCountdown = 60; // 60 seconds

        if (countdownInterval) {
          clearInterval(countdownInterval);
        }

        countdownInterval = setInterval(() => {
          refreshCountdown--;
          updateCountdownDisplay();

          if (refreshCountdown <= 0) {
            refreshCountdown = 60; // Reset for next cycle
          }
        }, 1000);

        updateCountdownDisplay();
      }

      function updateCountdownDisplay() {
        const countdownElement = document.getElementById("refreshCountdown");
        if (countdownElement && isAutoRefreshEnabled) {
          const minutes = Math.floor(refreshCountdown / 60);
          const seconds = refreshCountdown % 60;
          countdownElement.textContent = `${minutes}:${seconds
            .toString()
            .padStart(2, "0")}`;
        }
      }

      function updateLastRefreshTime() {
        const lastUpdatedElement = document.getElementById("lastUpdated");
        if (lastUpdatedElement) {
          const now = new Date();
          const timeString = now.toLocaleTimeString("en-US", {
            hour12: true,
            hour: "numeric",
            minute: "2-digit",
            second: "2-digit",
          });
          lastUpdatedElement.textContent = timeString;
        }
      }

      // Dark mode toggle for Tailwind
      function toggleDarkMode() {
        const html = document.documentElement;
        const isDark = html.classList.contains("dark");

        if (isDark) {
          html.classList.remove("dark");
          localStorage.setItem("theme", "light");
          document.getElementById("darkModeIcon").textContent = "üåô";
          document.getElementById("darkModeText").textContent = "Dark Mode";
        } else {
          html.classList.add("dark");
          localStorage.setItem("theme", "dark");
          document.getElementById("darkModeIcon").textContent = "‚òÄÔ∏è";
          document.getElementById("darkModeText").textContent = "Light Mode";
        }
      }

      // Initialize theme
      function initTheme() {
        const savedTheme = localStorage.getItem("theme");
        const prefersDark = window.matchMedia(
          "(prefers-color-scheme: dark)"
        ).matches;

        if (savedTheme === "dark" || (!savedTheme && prefersDark)) {
          document.documentElement.classList.add("dark");
          document.getElementById("darkModeIcon").textContent = "‚òÄÔ∏è";
          document.getElementById("darkModeText").textContent = "Light Mode";
        }
      }

      // Mobile detection and optimizations
      function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
               ('ontouchstart' in window) ||
               (navigator.maxTouchPoints > 0);
      }

      // Pull to refresh implementation
      class PullToRefresh {
        constructor() {
          this.touchStartY = 0;
          this.touchCurrentY = 0;
          this.isDragging = false;
          this.threshold = 100;
          this.element = document.getElementById('pullToRefresh');
          this.pullText = document.getElementById('pullText');
          this.isRefreshing = false;

          if (isMobileDevice()) {
            this.init();
          }
        }

        init() {
          document.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
          document.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
          document.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
        }

        handleTouchStart(e) {
          if (window.scrollY === 0) {
            this.touchStartY = e.touches[0].clientY;
            this.isDragging = true;
          }
        }

        handleTouchMove(e) {
          if (!this.isDragging || this.isRefreshing) return;

          this.touchCurrentY = e.touches[0].clientY;
          const distance = this.touchCurrentY - this.touchStartY;

          if (distance > 0 && window.scrollY === 0) {
            e.preventDefault();

            const progress = Math.min(distance / this.threshold, 1);
            const translateY = Math.min(distance * 0.5, 60);

            this.element.style.transform = `translateY(${translateY}px)`;
            this.element.style.opacity = progress;

            if (distance >= this.threshold) {
              this.pullText.textContent = 'Release to refresh';
              this.element.classList.add('pulling');
              triggerHaptic('light');
            } else {
              this.pullText.textContent = 'Pull to refresh';
              this.element.classList.remove('pulling');
            }
          }
        }

        handleTouchEnd() {
          if (!this.isDragging || this.isRefreshing) return;

          const distance = this.touchCurrentY - this.touchStartY;

          if (distance >= this.threshold) {
            this.refresh();
          } else {
            this.reset();
          }

          this.isDragging = false;
        }

        refresh() {
          this.isRefreshing = true;
          this.element.classList.add('refreshing');
          this.element.classList.remove('pulling');
          this.pullText.textContent = 'Refreshing...';

          triggerHaptic('success');

          // Trigger data refresh
          loadData(true);

          // Reset after refresh
          setTimeout(() => {
            this.reset();
            this.isRefreshing = false;
          }, 2000);
        }

        reset() {
          this.element.style.transform = '';
          this.element.style.opacity = '';
          this.element.classList.remove('pulling', 'refreshing');
          this.pullText.textContent = 'Pull to refresh';
        }
      }

      // Swipe gesture detection
      class SwipeDetector {
        constructor(element, callbacks) {
          this.element = element;
          this.callbacks = callbacks;
          this.touchStartX = 0;
          this.touchStartY = 0;
          this.touchEndX = 0;
          this.touchEndY = 0;
          this.minSwipeDistance = 50;
          this.maxVerticalDistance = 100;

          this.init();
        }

        init() {
          this.element.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: true });
          this.element.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: true });
        }

        handleTouchStart(e) {
          this.touchStartX = e.changedTouches[0].clientX;
          this.touchStartY = e.changedTouches[0].clientY;
        }

        handleTouchEnd(e) {
          this.touchEndX = e.changedTouches[0].clientX;
          this.touchEndY = e.changedTouches[0].clientY;
          this.handleSwipe();
        }

        handleSwipe() {
          const horizontalDistance = this.touchEndX - this.touchStartX;
          const verticalDistance = Math.abs(this.touchEndY - this.touchStartY);

          // Check if it's a horizontal swipe
          if (Math.abs(horizontalDistance) > this.minSwipeDistance && verticalDistance < this.maxVerticalDistance) {
            if (horizontalDistance > 0) {
              if (this.callbacks.onSwipeRight) this.callbacks.onSwipeRight();
            } else {
              if (this.callbacks.onSwipeLeft) this.callbacks.onSwipeLeft();
            }
          }
        }
      }

      // Initialize
      document.addEventListener("DOMContentLoaded", function () {
        // Initialize theme
        initTheme();

        // Initialize with empty week ranges - will be populated when data loads
        populateWeekRanges();

        // Enable auto refresh by default
        const btn = document.getElementById("autoRefreshBtn");
        const countdownIndicator = document.getElementById(
          "refreshCountdownIndicator"
        );
        if (isAutoRefreshEnabled) {
          autoRefreshInterval = setInterval(() => {
            if (!isLoadingData) {
              debugLog("Auto refreshing data...");
              loadData(true); // Force refresh for auto-refresh
            } else {
              debugLog("Skipping auto refresh - already loading");
            }
          }, AUTO_REFRESH_INTERVAL);

          btn.textContent = "‚è∞ Auto Refresh: ON";
          btn.className =
            "px-3 py-1.5 text-sm bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 text-white rounded-md font-bold transition-all duration-200 transform active:scale-95";
          countdownIndicator.classList.remove("hidden");
        }

        // Mobile optimizations
        if (isMobileDevice()) {
          // Add mobile-specific class for styling
          document.body.classList.add('touch-device');

          // Prevent double-tap zoom on buttons
          document.querySelectorAll('button, select').forEach(element => {
            element.style.touchAction = 'manipulation';
          });

          // Add passive listeners for better scroll performance
          document.addEventListener('touchstart', () => {}, { passive: true });
          document.addEventListener('touchmove', () => {}, { passive: true });

          // Initialize swipe gestures for date range navigation
          const heatmapContainers = document.querySelectorAll('#heatmapContainer, #averageHeatmapContainer');
          heatmapContainers.forEach(container => {
            new SwipeDetector(container, {
              onSwipeLeft: () => {
                // Navigate to next date range
                const select = document.getElementById('weekRange');
                if (select.selectedIndex < select.options.length - 1) {
                  select.selectedIndex++;
                  updateDateRange();
                  triggerHaptic('medium');
                }
              },
              onSwipeRight: () => {
                // Navigate to previous date range
                const select = document.getElementById('weekRange');
                if (select.selectedIndex > 0) {
                  select.selectedIndex--;
                  updateDateRange();
                  triggerHaptic('medium');
                }
              }
            });
          });
        }

        // Initialize pull to refresh
        new PullToRefresh();

        // Show skeleton loaders initially
        UI.showSkeletonLoader("heatmapContainer");
        UI.showSkeletonLoader("averageHeatmapContainer");

        // Load data - will use cache if available
        loadData();
      });
    </script>
  </body>
</html>
